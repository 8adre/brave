<?xml version="1.0" encoding="iso-8859-1" standalone="no"?>
<!-- Generated by the JDiff Javadoc doclet -->
<!-- (http://www.jdiff.org) -->
<!-- on Wed May 20 11:31:05 CEST 2020 -->

<api
  xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'
  xsi:noNamespaceSchemaLocation='api.xsd'
  name="brave-5.11.2"
  jdversion="1.0.9">

<!--  Command line arguments =  -doclet jdiff.JDiff -docletpath /home/heymjo/.m2/repository/jdiff/jdiff/1.0.9/jdiff-1.0.9.jar:/home/heymjo/.m2/repository/xml-apis/xml-apis/1.4.01/xml-apis-1.4.01.jar:/home/heymjo/.m2/repository/xerces/xercesImpl/2.10.0/xercesImpl-2.10.0.jar:/home/heymjo/.m2/repository/xml-resolver/xml-resolver/1.2/xml-resolver-1.2.jar -doclet jdiff.JDiff -docletpath /home/heymjo/.m2/repository/jdiff/jdiff/1.0.9/jdiff-1.0.9.jar:/home/heymjo/.m2/repository/xml-apis/xml-apis/1.4.01/xml-apis-1.4.01.jar:/home/heymjo/.m2/repository/xerces/xercesImpl/2.10.0/xercesImpl-2.10.0.jar:/home/heymjo/.m2/repository/xml-resolver/xml-resolver/1.2/xml-resolver-1.2.jar -apiname brave-5.11.2 -apidir /home/heymjo/src/zipkin/jdiff/5.11.2_to_5.12.3 -classpath /home/heymjo/.m2/repository/io/zipkin/zipkin2/zipkin/2.19.3/zipkin-2.19.3.jar:/home/heymjo/.m2/repository/io/zipkin/reporter2/zipkin-reporter/2.12.1/zipkin-reporter-2.12.1.jar:/home/heymjo/.m2/repository/io/zipkin/brave/brave/5.11.2/brave-5.11.2.jar -sourcepath /tmp/jdiff1947897144427515538/brave/5.11.2/sources -->
<package name="brave">
  <!-- start interface brave.Clock -->
  <interface name="Clock"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="currentTimeMicroseconds" return="long"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Epoch microseconds used for {@link zipkin2.Span#timestamp()} and {@link
 zipkin2.Annotation#timestamp()}.

 <p>This should use the most precise value possible. For example, {@code gettimeofday} or
 multiplying {@link System#currentTimeMillis} by 1000.

 <p>See <a href="https://zipkin.io/pages/instrumenting.html">Instrumenting a service</a> for
 more.]]>
    </doc>
  </interface>
  <!-- end interface brave.Clock -->
  <!-- start class brave.CurrentSpanCustomizer -->
  <class name="CurrentSpanCustomizer" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="brave.SpanCustomizer"/>
    <method name="create" return="brave.CurrentSpanCustomizer"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tracing" type="brave.Tracing"/>
      <doc>
      <![CDATA[Creates a span customizer that will affect the current span in scope if present]]>
      </doc>
    </method>
    <method name="name" return="brave.SpanCustomizer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[{@inheritDoc}]]>
      </doc>
    </method>
    <method name="tag" return="brave.SpanCustomizer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[{@inheritDoc}]]>
      </doc>
    </method>
    <method name="annotate" return="brave.SpanCustomizer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[{@inheritDoc}]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Provides a mechanism for end users to be able to customise the current span.

 <p>Handles the case of there being no current span in scope.]]>
    </doc>
  </class>
  <!-- end class brave.CurrentSpanCustomizer -->
  <!-- start class brave.ErrorParser -->
  <class name="ErrorParser" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ErrorParser"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="error"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="error" type="java.lang.Throwable"/>
      <param name="customizer" type="brave.SpanCustomizer"/>
      <doc>
      <![CDATA[Used to parse errors on a subtype of {@linkplain SpanCustomizer}]]>
      </doc>
    </method>
    <method name="error"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="error" type="java.lang.Throwable"/>
      <param name="span" type="brave.handler.MutableSpan"/>
      <doc>
      <![CDATA[Used to parse errors on a subtype of {@linkplain MutableSpan}]]>
      </doc>
    </method>
    <method name="error"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="error" type="java.lang.Throwable"/>
      <param name="span" type="java.lang.Object"/>
      <doc>
      <![CDATA[Override to change what data from the error are parsed into the span modeling it. By default,
 this tags "error" as the message or simple name of the type.]]>
      </doc>
    </method>
    <method name="annotate"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="span" type="java.lang.Object"/>
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Same behaviour as {@link brave.SpanCustomizer#annotate(String)}]]>
      </doc>
    </method>
    <method name="tag"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="span" type="java.lang.Object"/>
      <param name="key" type="java.lang.String"/>
      <param name="message" type="java.lang.String"/>
      <doc>
      <![CDATA[Same behaviour as {@link brave.SpanCustomizer#tag(String, String)}]]>
      </doc>
    </method>
    <field name="NOOP" type="brave.ErrorParser"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Adds no tags to the span representing the operation in error.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[This is a simplified type used for parsing errors. It only allows annotations or tags.

 @see Tags#ERROR]]>
    </doc>
  </class>
  <!-- end class brave.ErrorParser -->
  <!-- start class brave.NoopSpanCustomizer -->
  <class name="NoopSpanCustomizer" extends="java.lang.Enum"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="brave.SpanCustomizer"/>
    <method name="values" return="brave.NoopSpanCustomizer[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="brave.NoopSpanCustomizer"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="name" return="brave.SpanCustomizer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="tag" return="brave.SpanCustomizer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
      <param name="value" type="java.lang.String"/>
    </method>
    <method name="annotate" return="brave.SpanCustomizer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
    </method>
    <field name="INSTANCE" type="brave.NoopSpanCustomizer"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Performs no operations as the span represented by this is not sampled to report to the tracing
 system.]]>
    </doc>
  </class>
  <!-- end class brave.NoopSpanCustomizer -->
  <!-- start class brave.Request -->
  <class name="Request" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Request"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="spanKind" return="brave.Span.Kind"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The remote {@link Span.Kind} describing the direction and type of the request.]]>
      </doc>
    </method>
    <method name="unwrap" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the underlying request object or {@code null} if there is none. Here are some request
 objects: {@code org.apache.http.HttpRequest}, {@code org.apache.dubbo.rpc.Invocation}, {@code
 org.apache.kafka.clients.consumer.ConsumerRecord}.

 <p>Note: Some implementations are composed of multiple types, such as a request and a socket
 address of the client. Moreover, an implementation may change the type returned due to
 refactoring. Unless you control the implementation, cast carefully (ex using {@code
 instanceof}) instead of presuming a specific type will always be returned.

 @since 5.9]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Abstract request type used for parsing and sampling. When implemented, it will be the parameter
 of {@link SamplerFunction} or {@link TraceContext.Extractor}.

 <h3>No extensions outside Brave</h3>
 While this is an abstract type, it should not be subclassed outside the Brave repository. In
 other words, subtypes are sealed within this source tree.

 @see SamplerFunction
 @see TraceContext.Extractor
 @see TraceContext.Injector
 @see Response
 @since 5.9]]>
    </doc>
  </class>
  <!-- end class brave.Request -->
  <!-- start class brave.Response -->
  <class name="Response" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Response"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="spanKind" return="brave.Span.Kind"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The remote {@link Span.Kind} describing the direction and type of the response.]]>
      </doc>
    </method>
    <method name="request" return="brave.Request"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The request that initiated this response or {@code null} if unknown.

 <p>Implementations should return the last wire-level request that caused this response or
 error.]]>
      </doc>
    </method>
    <method name="error" return="java.lang.Throwable"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The error raised during response processing or {@code null} if there was none.

 <p>Lack of throwable, {@code null}, does not mean success. For example, in HTTP, there could
 be a 409 status code with no corresponding Java exception.

 <h3>Handling errors</h3>
 Handlers invoke {@link Span#error(Throwable)} prior to passing control to user-defined response
 parsers. This allows any {@link FinishedSpanHandler} to see the raw error via {@link
 MutableSpan#error()}, in case of export to a non-Zipkin backend such as metrics.

 <p>User-defined parsers can take any error here into consideration when deriving a {@link
 SpanCustomizer#tag(String, String) "error" tag}. For example, if they prefer defaults, they do
 nothing. If they have a better error tag value than what would be derived from the {@link
 Throwable}, they can overwrite it.]]>
      </doc>
    </method>
    <method name="unwrap" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the underlying response object or {@code null} if there is none. Here are some response
 objects: {@code org.apache.http.HttpResponse}, {@code org.apache.dubbo.rpc.Result}, {@code
 org.apache.kafka.clients.producer.RecordMetadata}.

 <p>Note: Some implementations are composed of multiple types, such as a response and matched
 route of the server. Moreover, an implementation may change the type returned due to
 refactoring. Unless you control the implementation, cast carefully (ex using {@code
 instanceof}) instead of presuming a specific type will always be returned.

 @since 5.10]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Abstract response type used for parsing.

 <h3>No extensions outside Brave</h3>
 While this is an abstract type, it should not be subclassed outside the Brave repository. In
 other words, subtypes are sealed within this source tree.

 @see Request
 @since 5.10]]>
    </doc>
  </class>
  <!-- end class brave.Response -->
  <!-- start class brave.ScopedSpan -->
  <class name="ScopedSpan" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="brave.SpanCustomizer"/>
    <method name="isNoop" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[When true, no recording will take place, so no data is reported on finish. However, the trace
 context is in scope until {@link #finish()} is called.

 @since 4.19]]>
      </doc>
    </method>
    <method name="context" return="brave.propagation.TraceContext"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the trace context associated with this span

 @since 4.19]]>
      </doc>
    </method>
    <method name="name" return="brave.ScopedSpan"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[{@inheritDoc}

 @since 5.11]]>
      </doc>
    </method>
    <method name="tag" return="brave.ScopedSpan"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[{@inheritDoc}

 @since 4.19]]>
      </doc>
    </method>
    <method name="annotate" return="brave.ScopedSpan"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[{@inheritDoc}

 @since 4.19]]>
      </doc>
    </method>
    <method name="error" return="brave.ScopedSpan"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="throwable" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[Adds tags depending on the configured {@link Tracing#errorParser() error parser}   *

 @since 4.19]]>
      </doc>
    </method>
    <method name="finish"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Closes the {@link CurrentTraceContext#newScope(TraceContext) scope} associated with this span,
 then reports the span complete, assigning the most precise duration possible.

 @since 4.19]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Used to model the latency of an operation within a method block.

 Here's a typical example of synchronous tracing from perspective of the scoped span:
 <pre>{@code
 // Note span methods chain. Explicitly start the span when ready.
 ScopedSpan span = tracer.startScopedSpan("encode");
 try {
   return encoder.encode();
 } catch (RuntimeException | Error e) {
   span.error(e); // Unless you handle exceptions, you might not know the operation failed!
   throw e;
 } finally {
   span.finish(); // finish - start = the duration of the operation in microseconds
 }
 }</pre>

 <h3>Usage notes</h3>
 All methods return {@linkplain ScopedSpan} for chaining, but the instance is always the same.
 Also, this type is intended for in-process synchronous code. Do not leak this onto another
 thread: it is not thread-safe. For advanced features or remote commands, use {@link Span}
 instead.

 @since 4.19]]>
    </doc>
  </class>
  <!-- end class brave.ScopedSpan -->
  <!-- start class brave.Span -->
  <class name="Span" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="brave.SpanCustomizer"/>
    <method name="isNoop" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[When true, no recording is done and nothing is reported to zipkin. However, this span should
 still be injected into outgoing requests. Use this flag to avoid performing expensive
 computation.]]>
      </doc>
    </method>
    <method name="context" return="brave.propagation.TraceContext"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="customizer" return="brave.SpanCustomizer"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a customizer appropriate for the current span. Prefer this when invoking user code]]>
      </doc>
    </method>
    <method name="start" return="brave.Span"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Starts the span with an implicit timestamp.

 <p>Spans can be modified before calling start. For example, you can add tags to the span and
 set its name without lock contention.]]>
      </doc>
    </method>
    <method name="start" return="brave.Span"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timestamp" type="long"/>
      <doc>
      <![CDATA[Like {@link #start()}, except with a given timestamp in microseconds.

 <p>Take extreme care with this feature as it is easy to have incorrect timestamps. If you must
 use this, generate the timestamp using {@link Tracing#clock(TraceContext)}.]]>
      </doc>
    </method>
    <method name="name" return="brave.Span"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[{@inheritDoc}]]>
      </doc>
    </method>
    <method name="kind" return="brave.Span"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="kind" type="brave.Span.Kind"/>
      <doc>
      <![CDATA[When present, the span is remote. This value clarifies how to interpret {@link
 #remoteServiceName(String)} and {@link #remoteIpAndPort(String, int)}.

 <p>Note: This affects Zipkin v1 format even if that format does not have a "kind" field. For
 example, if kind is {@link Kind#SERVER} and reported in v1 Zipkin format, the span's start
 timestamp is implicitly annotated as "sr" and that plus its duration as "ss".]]>
      </doc>
    </method>
    <method name="annotate" return="brave.Span"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[{@inheritDoc}]]>
      </doc>
    </method>
    <method name="annotate" return="brave.Span"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timestamp" type="long"/>
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Like {@link #annotate(String)}, except with a given timestamp in microseconds.

 <p>Take extreme care with this feature as it is easy to have incorrect timestamps. If you must
 use this, generate the timestamp using {@link Tracing#clock(TraceContext)}.]]>
      </doc>
    </method>
    <method name="tag" return="brave.Span"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[{@inheritDoc}]]>
      </doc>
    </method>
    <method name="error" return="brave.Span"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="throwable" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[Adds tags depending on the configured {@link Tracing#errorParser() error parser}]]>
      </doc>
    </method>
    <method name="remoteEndpoint" return="brave.Span"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Use {@link #remoteServiceName(String)} {@link #remoteIpAndPort(String, int)}. Will
 be removed in Brave v6.">
      <param name="endpoint" type="zipkin2.Endpoint"/>
      <doc>
      <![CDATA[@deprecated Use {@link #remoteServiceName(String)} {@link #remoteIpAndPort(String, int)}. Will
 be removed in Brave v6.]]>
      </doc>
    </method>
    <method name="remoteServiceName" return="brave.Span"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="remoteServiceName" type="java.lang.String"/>
      <doc>
      <![CDATA[Lower-case label of the remote node in the service graph, such as "favstar". Do not set if
 unknown. Avoid names with variables or unique identifiers embedded.

 <p>This is a primary label for trace lookup and aggregation, so it should be intuitive and
 consistent. Many use a name from service discovery.

 @see #remoteIpAndPort(String, int)]]>
      </doc>
    </method>
    <method name="remoteIpAndPort" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="remoteIp" type="java.lang.String"/>
      <param name="remotePort" type="int"/>
      <doc>
      <![CDATA[Sets the IP and port associated with the remote endpoint. For example, the server's listen
 socket or the connected client socket. This can also be set to forwarded values, such as an
 advertised IP.

 <p>Invalid inputs, such as hostnames, will return false. Port is only set with a valid IP, and
 zero or negative port values are ignored. For example, to set only the IP address, leave port
 as zero.

 <p>This returns boolean, not Span as it is often the case strings are malformed. Using this,
 you can do conditional parsing like so:
 <pre>{@code
 if (span.remoteIpAndPort(address.getHostAddress(), target.getPort())) return;
 span.remoteIpAndPort(address.getHostName(), target.getPort());
 }</pre>

 <p>Note: Comma separated lists are not supported. If you have multiple entries choose the one
 most indicative of the remote side. For example, the left-most entry in X-Forwarded-For.

 @param remoteIp the IPv4 or IPv6 literal representing the remote service connection
 @param remotePort the port associated with the IP, or zero if unknown.
 @see #remoteServiceName(String)
 @since 5.2]]>
      </doc>
    </method>
    <method name="finish"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Reports the span complete, assigning the most precise duration possible.]]>
      </doc>
    </method>
    <method name="abandon"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Throws away the current span without reporting it.]]>
      </doc>
    </method>
    <method name="finish"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timestamp" type="long"/>
      <doc>
      <![CDATA[Like {@link #finish()}, except with a given timestamp in microseconds.

 <p>{@link zipkin2.Span#duration() Zipkin's span duration} is derived by subtracting the start
 timestamp from this, and set when appropriate.

 <p>Take extreme care with this feature as it is easy to have incorrect timestamps. If you must
 use this, generate the timestamp using {@link Tracing#clock(TraceContext)}.]]>
      </doc>
    </method>
    <method name="flush"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Reports the span, even if unfinished. Most users will not call this method.

 <p>This primarily supports two use cases: one-way spans and orphaned spans. For example, a
 one-way span can be modeled as a span where one tracer calls start and another calls finish. In
 order to report that span from its origin, flush must be called.

 <p>Another example is where a user didn't call finish within a deadline or before a shutdown
 occurs. By flushing, you can report what was in progress.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Subtype of {@link SpanCustomizer} which can capture latency and remote context of an operation.

 Here's a typical example of synchronous tracing from perspective of the span:
 <pre>{@code
 // Note span methods chain. Explicitly start the span when ready.
 Span span = tracer.nextSpan().name("encode").start();
 // A span is not responsible for making itself current (scoped); the tracer is
 try (SpanInScope ws = tracer.withSpanInScope(span)) {
   return encoder.encode();
 } catch (RuntimeException | Error e) {
   span.error(e); // Unless you handle exceptions, you might not know the operation failed!
   throw e;
 } finally {
   span.finish(); // finish - start = the duration of the operation in microseconds
 }
 }</pre>

 <p>This captures duration of {@link #start()} until {@link #finish()} is called.

 <h3>Usage notes</h3>
 All methods return {@linkplain Span} for chaining, but the instance is always the same. Also,
 when only tracing in-process operations, consider {@link ScopedSpan}: a simpler api.]]>
    </doc>
  </class>
  <!-- end class brave.Span -->
  <!-- start class brave.Span.Kind -->
  <class name="Span.Kind" extends="java.lang.Enum"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="brave.Span.Kind[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="brave.Span.Kind"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <field name="CLIENT" type="brave.Span.Kind"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="SERVER" type="brave.Span.Kind"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="PRODUCER" type="brave.Span.Kind"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[When present, {@link #start()} is the moment a producer sent a message to a destination. A
 duration between {@link #start()} and {@link #finish()} may imply batching delay. {@link
 #remoteEndpoint(Endpoint)} indicates the destination, such as a broker.

 <p>Unlike {@link #CLIENT}, messaging spans never share a span ID. For example, the {@link
 #CONSUMER} of the same message has {@link TraceContext#parentId()} set to this span's {@link
 TraceContext#spanId()}.]]>
      </doc>
    </field>
    <field name="CONSUMER" type="brave.Span.Kind"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[When present, {@link #start()} is the moment a consumer received a message from an origin. A
 duration between {@link #start()} and {@link #finish()} may imply a processing backlog. while
 {@link #remoteEndpoint(Endpoint)} indicates the origin, such as a broker.

 <p>Unlike {@link #SERVER}, messaging spans never share a span ID. For example, the {@link
 #PRODUCER} of this message is the {@link TraceContext#parentId()} of this span.]]>
      </doc>
    </field>
  </class>
  <!-- end class brave.Span.Kind -->
  <!-- start interface brave.SpanCustomizer -->
  <interface name="SpanCustomizer"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="name" return="brave.SpanCustomizer"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the string name for the logical operation this span represents.]]>
      </doc>
    </method>
    <method name="tag" return="brave.SpanCustomizer"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Tags give your span context for search, viewing and analysis. For example, a key
 "your_app.version" would let you lookup spans by version. A tag "sql.query" isn't searchable,
 but it can help in debugging when viewing a trace.

 <p><em>Note:</em>To guard potentially expensive parsing, implement {@link Tag} instead, which
 avoids parsing into a no-op span.

 <p>Ex.
 <pre>{@code
 SUMMARY_TAG = new Tag<Summarizer>("summary") {
   @Override protected String parseValue(Summarizer input, TraceContext context) {
     return input.computeSummary();
   }
 }
 SUMMARY_TAG.tag(span);
 }</pre>

 @param key Name used to lookup spans, such as "your_app.version".
 @param value String value, cannot be <code>null</code>.
 @see Tag#tag(Object, SpanCustomizer)]]>
      </doc>
    </method>
    <method name="annotate" return="brave.SpanCustomizer"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Associates an event that explains latency with the current system time.

 @param value A short tag indicating the event, like "finagle.retry"]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Simple interface users can customize a span with. For example, this can add custom tags useful in
 looking up spans.

 <h3>Usage notes</h3>
 This type is safer to expose directly to users than {@link Span}, as it has no hooks that can
 affect the span lifecycle.

 @see Tag]]>
    </doc>
  </interface>
  <!-- end interface brave.SpanCustomizer -->
  <!-- start class brave.Tag -->
  <class name="Tag" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Tag" type="java.lang.String"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@since 5.11]]>
      </doc>
    </constructor>
    <method name="key" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="parseValue" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="input" type="java.lang.Object"/>
      <param name="context" type="brave.propagation.TraceContext"/>
      <doc>
      <![CDATA[Override to change what data from the input are parsed into the span modeling it. Any
 exceptions will be logged and ignored.

 @return The result to add as a span tag. {@code null} means no tag will be added. Note: empty
 string is a valid tag value!
 @since 5.11]]>
      </doc>
    </method>
    <method name="key" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="input" type="java.lang.Object"/>
      <doc>
      <![CDATA[Overrides the tag key based on the input]]>
      </doc>
    </method>
    <method name="tag"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="input" type="java.lang.Object"/>
      <param name="span" type="brave.ScopedSpan"/>
      <doc>
      <![CDATA[Tags the value parsed from the {@code input}.

 @since 5.11]]>
      </doc>
    </method>
    <method name="tag"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="input" type="java.lang.Object"/>
      <param name="span" type="brave.Span"/>
      <doc>
      <![CDATA[Tags the value parsed from the {@code input}.

 @since 5.11]]>
      </doc>
    </method>
    <method name="tag"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="input" type="java.lang.Object"/>
      <param name="context" type="brave.propagation.TraceContext"/>
      <param name="span" type="brave.SpanCustomizer"/>
      <doc>
      <![CDATA[Tags the value parsed from the {@code input}.

 @since 5.11]]>
      </doc>
    </method>
    <method name="tag"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="input" type="java.lang.Object"/>
      <param name="span" type="brave.SpanCustomizer"/>
      <doc>
      <![CDATA[Tags the value parsed from the {@code input}.

 @since 5.11]]>
      </doc>
    </method>
    <method name="tag"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="input" type="java.lang.Object"/>
      <param name="context" type="brave.propagation.TraceContext"/>
      <param name="span" type="brave.handler.MutableSpan"/>
      <doc>
      <![CDATA[Tags the value parsed from the {@code input}.

 @see FinishedSpanHandler#handle(TraceContext, MutableSpan)
 @since 5.11]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="validateNonEmpty" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="label" type="java.lang.String"/>
      <param name="value" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[This is a centralized type to parse a tag into any variant of a span. This also avoids the
 clutter of checking null or guarding on exceptions.

 Here's an example of a potentially expensive tag:
 <pre>{@code
 SUMMARY_TAG = new Tag<Summarizer>("summary") {
   @Override protected String parseValue(Summarizer input, TraceContext context) {
     return input.computeSummary();
   }
 }
 SUMMARY_TAG.tag(span);
 }</pre>

 @see Tags
 @see SpanCustomizer#tag(String, String)
 @see MutableSpan#tag(String, String)
 @since 5.11]]>
    </doc>
  </class>
  <!-- end class brave.Tag -->
  <!-- start class brave.Tags -->
  <class name="Tags" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <field name="ERROR" type="brave.Tag"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[This tags "error" as the message or simple name of the throwable.

 @see Span#error(Throwable)
 @since 5.11]]>
      </doc>
    </field>
    <field name="BAGGAGE_FIELD" type="brave.Tag"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[This tags the baggage value using {@link BaggageField#name()} as the key.

 @see BaggageField
 @since 5.11]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Standard tags used in parsers

 @since 5.11]]>
    </doc>
  </class>
  <!-- end class brave.Tags -->
  <!-- start class brave.Tracer -->
  <class name="Tracer" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="withSampler" return="brave.Tracer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Since 5.8, use {@link #nextSpan(SamplerFunction, Object)}  or {@link
 #startScopedSpan(String, SamplerFunction, Object)}">
      <param name="sampler" type="brave.sampler.Sampler"/>
      <doc>
      <![CDATA[@since 4.19
 @deprecated Since 5.8, use {@link #nextSpan(SamplerFunction, Object)}  or {@link
 #startScopedSpan(String, SamplerFunction, Object)}]]>
      </doc>
    </method>
    <method name="newTrace" return="brave.Span"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Explicitly creates a new trace. The result will be a root span (no parent span ID).

 <p>To implicitly create a new trace, or a span within an existing one, use {@link
 #nextSpan()}.]]>
      </doc>
    </method>
    <method name="joinSpan" return="brave.Span"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="context" type="brave.propagation.TraceContext"/>
      <doc>
      <![CDATA[Joining is re-using the same trace and span ids extracted from an incoming RPC request. This
 should not be used for messaging operations, as {@link #nextSpan(TraceContextOrSamplingFlags)}
 is a better choice.

 <p>When this incoming context is sampled, we assume this is a shared span, one where the
 caller and the current tracer report to the same span IDs. If no sampling decision occurred
 yet, we have exclusive access to this span ID.

 <p>Here's an example of conditionally joining a span, depending on if a trace context was
 extracted from an incoming request.

 <pre>{@code
 extracted = extractor.extract(request);
 span = contextOrFlags.context() != null
          ? tracer.joinSpan(contextOrFlags.context())
          : tracer.nextSpan(extracted);
 }</pre>

 <p><em>Note:</em> When {@link Propagation.Factory#supportsJoin()} is false, this will always
 fork a new child via {@link #newChild(TraceContext)}.

 @see Propagation
 @see Extractor#extract(Object)
 @see TraceContextOrSamplingFlags#context()
 @see #nextSpan(TraceContextOrSamplingFlags)]]>
      </doc>
    </method>
    <method name="newChild" return="brave.Span"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="parent" type="brave.propagation.TraceContext"/>
      <doc>
      <![CDATA[Explicitly creates a child within an existing trace. The result will be have its parent ID set
 to the input's span ID. If a sampling decision has not yet been made, one will happen here.

 <p>To implicitly create a new trace, or a span within an existing one, use {@link
 #nextSpan()}.]]>
      </doc>
    </method>
    <method name="nextSpan" return="brave.Span"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="extracted" type="brave.propagation.TraceContextOrSamplingFlags"/>
      <doc>
      <![CDATA[This creates a new span based on parameters extracted from an incoming request. This will
 always result in a new span. If no trace identifiers were extracted, a span will be created
 based on the implicit context in the same manner as {@link #nextSpan()}. If a sampling decision
 has not yet been made, one will happen here.

 <p>Ex.
 <pre>{@code
 extracted = extractor.extract(request);
 span = tracer.nextSpan(extracted);
 }</pre>

 <p><em>Note:</em> Unlike {@link #joinSpan(TraceContext)}, this does not attempt to re-use
 extracted span IDs. This means the extracted context (if any) is the parent of the span
 returned.

 <p><em>Note:</em> If a context could be extracted from the input, that trace is resumed, not
 whatever the {@link #currentSpan()} was. Make sure you re-apply {@link #withSpanInScope(Span)}
 so that data is written to the correct trace.

 @see Propagation
 @see Extractor#extract(Object)
 @see #nextSpan(SamplerFunction, Object)]]>
      </doc>
    </method>
    <method name="toSpan" return="brave.Span"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="context" type="brave.propagation.TraceContext"/>
      <doc>
      <![CDATA[Converts the context to a Span object after decorating it for propagation]]>
      </doc>
    </method>
    <method name="withSpanInScope" return="brave.Tracer.SpanInScope"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="span" type="brave.Span"/>
      <doc>
      <![CDATA[Makes the given span the "current span" and returns an object that exits that scope on close.
 Calls to {@link #currentSpan()} and {@link #currentSpanCustomizer()} will affect this span
 until the return value is closed.

 <p>The most convenient way to use this method is via the try-with-resources idiom.

 Ex.
 <pre>{@code
 // Assume a framework interceptor uses this method to set the inbound span as current
 try (SpanInScope ws = tracer.withSpanInScope(span)) {
   return inboundRequest.invoke();
 // note: try-with-resources closes the scope *before* the catch block
 } catch (RuntimeException | Error e) {
   span.error(e);
   throw e;
 } finally {
   span.finish();
 }

 // An unrelated framework interceptor can now lookup the correct parent for outbound requests
 Span parent = tracer.currentSpan()
 Span span = tracer.nextSpan().name("outbound").start(); // parent is implicitly looked up
 try (SpanInScope ws = tracer.withSpanInScope(span)) {
   return outboundRequest.invoke();
 // note: try-with-resources closes the scope *before* the catch block
 } catch (RuntimeException | Error e) {
   span.error(e);
   throw e;
 } finally {
   span.finish();
 }
 }</pre>

 <p>When tracing in-process commands, prefer {@link #startScopedSpan(String)} which scopes by
 default.

 <p>Note: While downstream code might affect the span, calling this method, and calling close
 on the result have no effect on the input. For example, calling close on the result does not
 finish the span. Not only is it safe to call close, you must call close to end the scope, or
 risk leaking resources associated with the scope.

 @param span span to place into scope or null to clear the scope]]>
      </doc>
    </method>
    <method name="currentSpanCustomizer" return="brave.SpanCustomizer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a customizer for current span in scope or noop if there isn't one.

 <p>Unlike {@link CurrentSpanCustomizer}, this represents a single span. Accordingly, this
 reference should not be saved as a field. That said, it is more efficient to save this result
 as a method-local variable vs repeated calls.]]>
      </doc>
    </method>
    <method name="currentSpan" return="brave.Span"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the current span in scope or null if there isn't one.

 <p>When entering user code, prefer {@link #currentSpanCustomizer()} as it is a stable type and
 will never return null.]]>
      </doc>
    </method>
    <method name="nextSpan" return="brave.Span"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a new child span if there's a {@link #currentSpan()} or a new trace if there isn't.

 <p>Prefer {@link #startScopedSpan(String)} if you are tracing a synchronous function or code
 block.]]>
      </doc>
    </method>
    <method name="startScopedSpan" return="brave.ScopedSpan"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns a new child span if there's a {@link #currentSpan()} or a new trace if there isn't. The
 result is the "current span" until {@link ScopedSpan#finish()} is called.

 Here's an example:
 <pre>{@code
 ScopedSpan span = tracer.startScopedSpan("encode");
 try {
   // The span is in "scope" so that downstream code such as loggers can see trace IDs
   return encoder.encode();
 } catch (RuntimeException | Error e) {
   span.error(e); // Unless you handle exceptions, you might not know the operation failed!
   throw e;
 } finally {
   span.finish();
 }
 }</pre>]]>
      </doc>
    </method>
    <method name="startScopedSpan" return="brave.ScopedSpan"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="samplerFunction" type="brave.sampler.SamplerFunction"/>
      <param name="arg" type="java.lang.Object"/>
      <doc>
      <![CDATA[Like {@link #startScopedSpan(String)} except when there is no trace in process, the sampler
 {@link SamplerFunction#trySample(Object) triggers} against the supplied argument.

 @param name the {@link Span#name(String) span name}
 @param samplerFunction invoked if there's no {@link CurrentTraceContext#get() current trace}
 @param arg parameter to {@link SamplerFunction#trySample(Object)}
 @see #nextSpan(SamplerFunction, Object)
 @since 5.8]]>
      </doc>
    </method>
    <method name="nextSpan" return="brave.Span"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="samplerFunction" type="brave.sampler.SamplerFunction"/>
      <param name="arg" type="java.lang.Object"/>
      <doc>
      <![CDATA[Like {@link #nextSpan()} except when there is no trace in process, the sampler {@link
 SamplerFunction#trySample(Object) triggers} against the supplied argument.

 @param samplerFunction invoked if there's no {@link CurrentTraceContext#get() current trace}
 @param arg parameter to {@link SamplerFunction#trySample(Object)}
 @see #startScopedSpan(String, SamplerFunction, Object)
 @see #nextSpan(TraceContextOrSamplingFlags)
 @since 5.8]]>
      </doc>
    </method>
    <method name="nextSpanWithParent" return="brave.Span"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="samplerFunction" type="brave.sampler.SamplerFunction"/>
      <param name="arg" type="java.lang.Object"/>
      <param name="parent" type="brave.propagation.TraceContext"/>
      <doc>
      <![CDATA[Like {@link #nextSpan(SamplerFunction, Object)} except this controls the parent context
 explicitly. This is useful when an invocation context is propagated manually, commonly
 the case with asynchronous client frameworks.

 @param samplerFunction invoked if there's no {@link CurrentTraceContext#get() current trace}
 @param arg parameter to {@link SamplerFunction#trySample(Object)}
 @param parent of the new span, or {@code null} if it should have no parent
 @see #nextSpan(SamplerFunction, Object)
 @since 5.10]]>
      </doc>
    </method>
    <method name="startScopedSpanWithParent" return="brave.ScopedSpan"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="parent" type="brave.propagation.TraceContext"/>
      <doc>
      <![CDATA[Same as {@link #startScopedSpan(String)}, except ignores the current trace context.

 <p>Use this when you are creating a scoped span in a method block where the parent was
 created. You can also use this to force a new trace by passing null parent.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Using a tracer, you can create a root span capturing the critical path of a request. Child spans
 can be created to allocate latency relating to outgoing requests.

 When tracing single-threaded code, just run it inside a scoped span:
 <pre>{@code
 // Start a new trace or a span within an existing trace representing an operation
 ScopedSpan span = tracer.startScopedSpan("encode");
 try {
   // The span is in "scope" so that downstream code such as loggers can see trace IDs
   return encoder.encode();
 } catch (RuntimeException | Error e) {
   span.error(e); // Unless you handle exceptions, you might not know the operation failed!
   throw e;
 } finally {
   span.finish();
 }
 }</pre>

 <p>When you need more features, or finer control, use the {@linkplain Span} type:
 <pre>{@code
 // Start a new trace or a span within an existing trace representing an operation
 Span span = tracer.nextSpan().name("encode").start();
 // Put the span in "scope" so that downstream code such as loggers can see trace IDs
 try (SpanInScope ws = tracer.withSpanInScope(span)) {
   return encoder.encode();
 } catch (RuntimeException | Error e) {
   span.error(e); // Unless you handle exceptions, you might not know the operation failed!
   throw e;
 } finally {
   span.finish(); // note the scope is independent of the span. Always finish a span.
 }
 }</pre>

 <p>Both of the above examples report the exact same span on finish!

 @see Span
 @see ScopedSpan
 @see Propagation]]>
    </doc>
  </class>
  <!-- end class brave.Tracer -->
  <!-- start class brave.Tracer.SpanInScope -->
  <class name="Tracer.SpanInScope" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Closeable"/>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[No exceptions are thrown when unbinding a span scope.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A span remains in the scope it was bound to until close is called.]]>
    </doc>
  </class>
  <!-- end class brave.Tracer.SpanInScope -->
  <!-- start class brave.Tracing -->
  <class name="Tracing" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Closeable"/>
    <method name="newBuilder" return="brave.Tracing.Builder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="tracer" return="brave.Tracer"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[All tracing commands start with a {@link Span}. Use a tracer to create spans.]]>
      </doc>
    </method>
    <method name="propagation" return="brave.propagation.Propagation"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[When a trace leaves the process, it needs to be propagated, usually via headers. This utility
 is used to inject or extract a trace context from remote requests.]]>
      </doc>
    </method>
    <method name="propagationFactory" return="brave.propagation.Propagation.Factory"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[This supports edge cases like GRPC Metadata propagation which doesn't use String keys.]]>
      </doc>
    </method>
    <method name="sampler" return="brave.sampler.Sampler"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Sampler is responsible for deciding if a particular trace should be "sampled", i.e. whether the
 overhead of tracing will occur and/or if a trace will be reported to Zipkin.

 @see Tracer#nextSpan(SamplerFunction, Object) for temporary overrides]]>
      </doc>
    </method>
    <method name="currentTraceContext" return="brave.propagation.CurrentTraceContext"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[This supports in-process propagation, typically across thread boundaries. This includes
 utilities for concurrent types like {@linkplain java.util.concurrent.ExecutorService}.]]>
      </doc>
    </method>
    <method name="clock" return="brave.Clock"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="context" type="brave.propagation.TraceContext"/>
      <doc>
      <![CDATA[This exposes the microsecond clock used by operations such as {@link Span#finish()}. This is
 helpful when you want to time things manually. Notably, this clock will be coherent for all
 child spans in this trace (that use this tracing component). For example, NTP or system clock
 changes will not affect the result.

 @param context references a potentially unstarted span you'd like a clock correlated with]]>
      </doc>
    </method>
    <method name="errorParser" return="brave.ErrorParser"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="current" return="brave.Tracing"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the most recently created tracing component iff it hasn't been closed. null otherwise.

 <p>This object should not be cached.]]>
      </doc>
    </method>
    <method name="currentTracer" return="brave.Tracer"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the most recently created tracer if its component hasn't been closed. null otherwise.

 <p>This object should not be cached.]]>
      </doc>
    </method>
    <method name="isNoop" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[When true, no recording is done and nothing is reported to zipkin. However, trace context is
 still injected into outgoing requests.

 @see Span#isNoop()]]>
      </doc>
    </method>
    <method name="setNoop"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="noop" type="boolean"/>
      <doc>
      <![CDATA[Set true to drop data and only return {@link Span#isNoop() noop spans} regardless of sampling
 policy. This allows operators to stop tracing in risk scenarios.

 @see #isNoop()]]>
      </doc>
    </method>
    <method name="close"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Ensures this component can be garbage collected, by making it not {@link #current()}]]>
      </doc>
    </method>
    <doc>
    <![CDATA[This provides utilities needed for trace instrumentation. For example, a {@link Tracer}.

 <p>Instances built via {@link #newBuilder()} are registered automatically such that statically
 configured instrumentation like JDBC drivers can use {@link #current()}.

 <p>This type can be extended so that the object graph can be built differently or overridden,
 for example via spring or when mocking.]]>
    </doc>
  </class>
  <!-- end class brave.Tracing -->
  <!-- start class brave.Tracing.Builder -->
  <class name="Tracing.Builder" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="localServiceName" return="brave.Tracing.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="localServiceName" type="java.lang.String"/>
      <doc>
      <![CDATA[Label of the remote node in the service graph, such as "favstar". Avoid names with variables
 or unique identifiers embedded. Defaults to "unknown".

 <p>This is a primary label for trace lookup and aggregation, so it should be intuitive and
 consistent. Many use a name from service discovery.

 @see #localIp(String)]]>
      </doc>
    </method>
    <method name="localIp" return="brave.Tracing.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="localIp" type="java.lang.String"/>
      <doc>
      <![CDATA[The text representation of the primary IP address associated with this service. Ex.
 192.168.99.100 or 2001:db8::c001. Defaults to a link local IP.

 @see #localServiceName(String)
 @see #localPort(int)
 @since 5.2]]>
      </doc>
    </method>
    <method name="localPort" return="brave.Tracing.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="localPort" type="int"/>
      <doc>
      <![CDATA[The primary listen port associated with this service. No default.

 @see #localIp(String)
 @since 5.2]]>
      </doc>
    </method>
    <method name="endpoint" return="brave.Tracing.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Use {@link #localServiceName(String)} {@link #localIp(String)} and {@link
 #localPort(int)}. Will be removed in Brave v6.">
      <param name="endpoint" type="zipkin2.Endpoint"/>
      <doc>
      <![CDATA[Sets the {@link zipkin2.Span#localEndpoint() Endpoint of the local service} being traced.

 @deprecated Use {@link #localServiceName(String)} {@link #localIp(String)} and {@link
 #localPort(int)}. Will be removed in Brave v6.]]>
      </doc>
    </method>
    <method name="spanReporter" return="brave.Tracing.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="spanReporter" type="zipkin2.reporter.Reporter"/>
      <doc>
      <![CDATA[Controls how spans are reported. Defaults to logging, but often an {@link AsyncReporter}
 which batches spans before sending to Zipkin.

 The {@link AsyncReporter} includes a {@link Sender}, which is a driver for transports like
 http, kafka and scribe.

 <p>For example, here's how to batch send spans via http:

 <pre>{@code
 spanReporter = AsyncReporter.create(URLConnectionSender.create("http://localhost:9411/api/v2/spans"));

 tracingBuilder.spanReporter(spanReporter);
 }</pre>

 <p>See https://github.com/openzipkin/zipkin-reporter-java]]>
      </doc>
    </method>
    <method name="clock" return="brave.Tracing.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="clock" type="brave.Clock"/>
      <doc>
      <![CDATA[Assigns microsecond-resolution timestamp source for operations like {@link Span#start()}.
 Defaults to JRE-specific platform time.

 <p>Note: timestamps are read once per trace, then {@link System#nanoTime() ticks}
 thereafter. This ensures there's no clock skew problems inside a single trace.

 See {@link Tracing#clock(TraceContext)}]]>
      </doc>
    </method>
    <method name="sampler" return="brave.Tracing.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sampler" type="brave.sampler.Sampler"/>
      <doc>
      <![CDATA[Sampler is responsible for deciding if a particular trace should be "sampled", i.e. whether
 the overhead of tracing will occur and/or if a trace will be reported to Zipkin.

 @see Tracer#nextSpan(SamplerFunction, Object) for temporary overrides]]>
      </doc>
    </method>
    <method name="currentTraceContext" return="brave.Tracing.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="currentTraceContext" type="brave.propagation.CurrentTraceContext"/>
      <doc>
      <![CDATA[Responsible for implementing {@link Tracer#startScopedSpan(String)}, {@link
 Tracer#currentSpanCustomizer()}, {@link Tracer#currentSpan()} and {@link
 Tracer#withSpanInScope(Span)}.

 <p>By default a simple thread-local is used. Override to support other mechanisms or to
 synchronize with other mechanisms such as SLF4J's MDC.]]>
      </doc>
    </method>
    <method name="propagationFactory" return="brave.Tracing.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="propagationFactory" type="brave.propagation.Propagation.Factory"/>
      <doc>
      <![CDATA[Controls how trace contexts are injected or extracted from remote requests, such as from http
 headers. Defaults to {@link B3Propagation#FACTORY}]]>
      </doc>
    </method>
    <method name="traceId128Bit" return="brave.Tracing.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="traceId128Bit" type="boolean"/>
      <doc>
      <![CDATA[When true, new root spans will have 128-bit trace IDs. Defaults to false (64-bit)]]>
      </doc>
    </method>
    <method name="supportsJoin" return="brave.Tracing.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="supportsJoin" type="boolean"/>
      <doc>
      <![CDATA[True means the tracing system supports sharing a span ID between a {@link Span.Kind#CLIENT}
 and {@link Span.Kind#SERVER} span. Defaults to true.

 <p>Set this to false when the tracing system requires the opposite. For example, if
 ultimately spans are sent to Amazon X-Ray or Google Stackdriver Trace, you should set this to
 false.

 <p>This is implicitly set to false when {@link Propagation.Factory#supportsJoin()} is false,
 as in that case, sharing IDs isn't possible anyway.

 @see Propagation.Factory#supportsJoin()]]>
      </doc>
    </method>
    <method name="errorParser" return="brave.Tracing.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="errorParser" type="brave.ErrorParser"/>
    </method>
    <method name="addFinishedSpanHandler" return="brave.Tracing.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="handler" type="brave.handler.FinishedSpanHandler"/>
      <doc>
      <![CDATA[Similar to {@link #spanReporter(Reporter)} except it can read the trace context and create
 more efficient or completely different data structures. Importantly, the input is mutable for
 customization purposes.

 <p>These handlers execute before the {@link #spanReporter(Reporter) span reporter}, which
 means any mutations occur prior to Zipkin.

 <h3>Advanced notes</h3>

 <p>This is named firehose as it can receive data even when spans are not sampled remotely.
 For example, {@link FinishedSpanHandler#alwaysSampleLocal()} will generate data for all
 traced requests while not affecting headers. This setting is often used for metrics
 aggregation.


 <p>Your handler can also be a custom span transport. When this is the case, set the {@link
 #spanReporter(Reporter) span reporter} to {@link Reporter#NOOP} to avoid redundant conversion
 overhead.

 @param handler skipped if {@link FinishedSpanHandler#NOOP} or already added
 @see #alwaysReportSpans()
 @see TraceContext#sampledLocal()]]>
      </doc>
    </method>
    <method name="alwaysReportSpans" return="brave.Tracing.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[When true, all spans {@link TraceContext#sampledLocal() sampled locally} are reported to the
 {@link #spanReporter(Reporter) span reporter}, even if they aren't sampled remotely. Defaults
 to false.

 <p>The primary use case is to implement a <a href="https://github.com/openzipkin-contrib/zipkin-secondary-sampling">sampling
 overlay</a>, such as boosting the sample rate for a subset of the network depending on the
 value of a {@link BaggageField baggage field}. This means that data will report when either
 the trace is normally sampled, or secondarily sampled via a custom header.

 <p>This is simpler than {@link #addFinishedSpanHandler(FinishedSpanHandler)}, because you
 don't have to duplicate transport mechanics already implemented in the {@link
 #spanReporter(Reporter) span reporter}. However, this assumes your backend can properly
 process the partial traces implied when using conditional sampling. For example, if your
 sampling condition is not consistent on a call tree, the resulting data could appear broken.

 @see #addFinishedSpanHandler(FinishedSpanHandler)
 @see TraceContext#sampledLocal()
 @since 5.8]]>
      </doc>
    </method>
    <method name="trackOrphans" return="brave.Tracing.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[When true, this logs the caller which orphaned a span to the category "brave.Tracer" at
 {@link Level#FINE}. Defaults to false.

 <p>If you see data with the annotation "brave.flush", you may have an instrumentation bug.
 To see which code was involved, set this and ensure the logger {@link Tracing} is at {@link
 Level#FINE}. Do not do this in production as tracking orphaned data incurs higher overhead.

 @see FinishedSpanHandler#supportsOrphans()
 @since 5.9]]>
      </doc>
    </method>
    <method name="build" return="brave.Tracing"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class brave.Tracing.Builder -->
  <!-- start interface brave.TracingCustomizer -->
  <interface name="TracingCustomizer"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="customize"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="builder" type="brave.Tracing.Builder"/>
    </method>
    <field name="NOOP" type="brave.TracingCustomizer"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Use to avoid comparing against null references]]>
      </doc>
    </field>
    <doc>
    <![CDATA[This allows configuration plugins to collaborate on building an instance of {@link Tracing}.

 <p>For example a customizer can configure {@link Tracing.Builder#addFinishedSpanHandler(FinishedSpanHandler)
 finished span handlers} without having to also configure {@link Tracing.Builder#spanReporter(Reporter)
 span reporting}.

 <h3>Integration examples</h3>

 <p>In practice, a dependency injection tool applies a collection of these instances prior to
 {@link Tracing.Builder#build() building the tracing instance}. For example, an injected {@code
 List<TracingCustomizer>} parameter to a provider of {@link Tracing}.

 <p>Here are some examples, in alphabetical order:
 <pre><ul>
   <li><a href="https://dagger.dev/multibindings.html">Dagger Set Multibindings</a></li>
   <li><a href="http://google.github.io/guice/api-docs/latest/javadoc/com/google/inject/multibindings/Multibinder.html">Guice Set Multibinder</a></li>
   <li><a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-autowired-annotation">Spring Autowired Collections</a></li>
 </ul></pre>

 @see BaggagePropagationCustomizer
 @see CurrentTraceContextCustomizer
 @since 5.7]]>
    </doc>
  </interface>
  <!-- end interface brave.TracingCustomizer -->
</package>
<package name="brave.baggage">
  <!-- start class brave.baggage.BaggageField -->
  <class name="BaggageField" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="create" return="brave.baggage.BaggageField"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[@param name See {@link #name()}
 @since 5.11]]>
      </doc>
    </method>
    <method name="getAll" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="context" type="brave.propagation.TraceContext"/>
      <doc>
      <![CDATA[Gets any fields in the in given trace context.

 @since 5.11]]>
      </doc>
    </method>
    <method name="getAll" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="extracted" type="brave.propagation.TraceContextOrSamplingFlags"/>
      <doc>
      <![CDATA[Gets any fields in the in the {@linkplain TraceContext.Extractor#extract(Object) extracted
 result}.

 @since 5.11]]>
      </doc>
    </method>
    <method name="getAll" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Like {@link #getAll(TraceContext)} except against the current trace context.

 <p>Prefer {@link #getAll(TraceContext)} if you have a reference to the trace context.

 @since 5.11]]>
      </doc>
    </method>
    <method name="getByName" return="brave.baggage.BaggageField"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="context" type="brave.propagation.TraceContext"/>
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Looks up the field by {@code name}, useful for when you do not have a reference to it. In
 general, {@link BaggageField}s should be referenced directly as constants where possible.

 @since 5.11]]>
      </doc>
    </method>
    <method name="getByName" return="brave.baggage.BaggageField"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="extracted" type="brave.propagation.TraceContextOrSamplingFlags"/>
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Looks up the field by {@code name}, useful for when you do not have a reference to it. In
 general, {@link BaggageField}s should be referenced directly as constants where possible.

 @since 5.11]]>
      </doc>
    </method>
    <method name="getByName" return="brave.baggage.BaggageField"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Like {@link #getByName(TraceContext, String)} except against the current trace context.

 <p>Prefer {@link #getByName(TraceContext, String)} if you have a reference to the trace
 context.

 @since 5.11]]>
      </doc>
    </method>
    <method name="name" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The non-empty name of the field. Ex "userId".

 <p>For example, if using log correlation and with field named "userId", the {@linkplain
 #getValue(TraceContext) value} becomes the log variable {@code %{userId}} when the span is next
 made current.

 @see #getByName(TraceContext, String)
 @see CorrelationScopeConfig.SingleCorrelationField#name()
 @since 5.11]]>
      </doc>
    </method>
    <method name="getValue" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="context" type="brave.propagation.TraceContext"/>
      <doc>
      <![CDATA[Returns the most recent value for this field in the context or null if unavailable.

 <p>The result may not be the same as the one {@link TraceContext.Extractor#extract(Object)
 extracted} from the incoming context because {@link #updateValue(String)} can override it.

 @since 5.11]]>
      </doc>
    </method>
    <method name="getValue" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Like {@link #getValue(TraceContext)} except against the current trace context.

 <p>Prefer {@link #getValue(TraceContext)} if you have a reference to the trace context.

 @since 5.11]]>
      </doc>
    </method>
    <method name="getValue" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="extracted" type="brave.propagation.TraceContextOrSamplingFlags"/>
      <doc>
      <![CDATA[Like {@link #getValue(TraceContext)} except for use cases that precede a span. For example, a
 {@linkplain TraceContextOrSamplingFlags#traceIdContext() trace ID context}.

 @since 5.11]]>
      </doc>
    </method>
    <method name="updateValue" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="context" type="brave.propagation.TraceContext"/>
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Updates the value of the this field, or ignores if read-only or not configured.

 @since 5.11]]>
      </doc>
    </method>
    <method name="updateValue" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="extracted" type="brave.propagation.TraceContextOrSamplingFlags"/>
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Like {@link #updateValue(TraceContextOrSamplingFlags, String)} except for use cases that
 precede a span. For example, a {@linkplain TraceContextOrSamplingFlags#traceIdContext() trace
 ID context}.

 @since 5.11]]>
      </doc>
    </method>
    <method name="updateValue" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Like {@link #updateValue(TraceContext, String)} except against the current trace context.

 <p>Prefer {@link #updateValue(TraceContext, String)} if you have a reference to the trace
 context.

 @since 5.11]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns true for any baggage field with the same name (case insensitive).]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the same value for any baggage field with the same name (case insensitive).]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Defines a trace context scoped field, usually but not always analogous to an HTTP header. Fields
 will be no-op unless {@link BaggagePropagation} is configured.

 <p>For example, if you have a need to know a specific request's country code in a downstream
 service, you can propagate it through the trace:
 <pre>{@code
 // Configure your baggage field
 COUNTRY_CODE = BaggageField.create("country-code");
 }</pre>

 <h3>Usage</h3>
 As long as a field is configured with {@link BaggagePropagation}, local reads and updates are
 possible in-process.

 <p>Ex. once added to `BaggagePropagation`, you can call below to affect the country code
 of the current trace context:
 <pre>{@code
 COUNTRY_CODE.updateValue("FO");
 String countryCode = COUNTRY_CODE.get();
 }</pre>

 <p>Or, if you have a reference to a trace context, it is more efficient to use it explicitly:
 <pre>{@code
 COUNTRY_CODE.updateValue(span.context(), "FO");
 String countryCode = COUNTRY_CODE.get(span.context());
 Tags.BAGGAGE_FIELD.tag(COUNTRY_CODE, span);
 }</pre>

 <p>Correlation</p>

 <p>You can also integrate baggage with other correlated contexts such as logging:
 <pre>{@code
 import brave.baggage.BaggagePropagationConfig.SingleBaggageField;
 import brave.baggage.CorrelationScopeConfig.SingleCorrelationField;

 AMZN_TRACE_ID = BaggageField.create("x-amzn-trace-id");

 // Allow logging patterns like %X{traceId} %X{x-amzn-trace-id}
 decorator = MDCScopeDecorator.newBuilder()
                              .add(SingleCorrelationField.create(AMZN_TRACE_ID)).build()

 tracingBuilder.propagationFactory(BaggagePropagation.newFactoryBuilder(B3Propagation.FACTORY)
                                                     .add(SingleBaggageField.remote(AMZN_TRACE_ID))
                                                     .build())
               .currentTraceContext(ThreadLocalCurrentTraceContext.newBuilder()
                                                                  .addScopeDecorator(decorator)
                                                                  .build())
 }</pre>

 <h3>Appropriate usage</h3>
 It is generally not a good idea to use the tracing system for application logic or critical code
 such as security context propagation.

 <p>Brave is an infrastructure library: you will create lock-in if you expose its apis into
 business code. Prefer exposing your own types for utility functions that use this class as this
 will insulate you from lock-in.

 <p>While it may seem convenient, do not use this for security context propagation as it was not
 designed for this use case. For example, anything placed in here can be accessed by any code in
 the same classloader!

 <h3>Background</h3>
 The name Baggage was first introduced by Brown University in <a href="https://people.mpi-sws.org/~jcmace/papers/mace2015pivot.pdf">Pivot
 Tracing</a> as maps, sets and tuples. They then spun baggage out as a standalone component, <a
 href="https://people.mpi-sws.org/~jcmace/papers/mace2018universal.pdf">BaggageContext</a> and
 considered some of the nuances of making it general purpose. The implementations proposed in
 these papers are different to the implementation here, but conceptually the goal is the same: to
 propagate "arbitrary stuff" with a request.

 @see BaggagePropagation
 @see CorrelationScopeConfig
 @since 5.11]]>
    </doc>
  </class>
  <!-- end class brave.baggage.BaggageField -->
  <!-- start class brave.baggage.BaggageFields -->
  <class name="BaggageFields" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="BaggageFields"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="constant" return="brave.baggage.BaggageField"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Creates a local baggage field based on a possibly null constant, such as an ENV variable.

 <p>Ex.
 <pre>{@code
 CLOUD_REGION = BaggageFields.constant("region", System.getEnv("CLOUD_REGION"));
 }</pre>

 @since 5.11]]>
      </doc>
    </method>
    <field name="TRACE_ID" type="brave.baggage.BaggageField"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[This is the most common log correlation field.

 @see TraceContext#traceIdString()
 @since 5.11]]>
      </doc>
    </field>
    <field name="PARENT_ID" type="brave.baggage.BaggageField"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Typically only useful when spans are parsed from log records.

 @see TraceContext#parentIdString()
 @since 5.11]]>
      </doc>
    </field>
    <field name="SPAN_ID" type="brave.baggage.BaggageField"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Used with {@link #TRACE_ID} to correlate a log line with a span.

 @see TraceContext#spanIdString()
 @since 5.11]]>
      </doc>
    </field>
    <field name="SAMPLED" type="brave.baggage.BaggageField"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[This is only useful when {@link #TRACE_ID} is also a baggage field. It is a hint that a trace
 may exist in Zipkin, when a user is viewing logs. For example, unsampled traces are not
 typically reported to Zipkin.

 @see TraceContext#sampled()
 @since 5.11]]>
      </doc>
    </field>
    <doc>
    <![CDATA[This contains pre-defined fields, such as {@link #TRACE_ID} and a way to create a {@linkplain
 #constant(String, String) constant field}.

 <h3>Built-in fields</h3>
 The following are fields that dispatch to methods on the {@link TraceContext}. They are available
 regardless of {@link BaggagePropagation}. None will return in lookups such as {@link
 BaggageField#getAll(TraceContext)} or {@link BaggageField#getByName(TraceContext, String)}

 <p><ol>
 <li>{@link #TRACE_ID}</li>
 <li>{@link #PARENT_ID}</li>
 <li>{@link #SPAN_ID}</li>
 <li>{@link #SAMPLED}</li>
 </ol>

 @since 5.11]]>
    </doc>
  </class>
  <!-- end class brave.baggage.BaggageFields -->
  <!-- start class brave.baggage.BaggagePropagation -->
  <class name="BaggagePropagation" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="brave.propagation.Propagation"/>
    <method name="newFactoryBuilder" return="brave.baggage.BaggagePropagation.FactoryBuilder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delegate" type="brave.propagation.Propagation.Factory"/>
      <doc>
      <![CDATA[Wraps an underlying propagation implementation, pushing one or more fields.]]>
      </doc>
    </method>
    <method name="keys" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Only returns trace context keys. Baggage field names are not returned to ensure tools don't
 delete them. This is to support users accessing baggage without Brave apis (ex via headers).]]>
      </doc>
    </method>
    <method name="injector" return="brave.propagation.TraceContext.Injector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="setter" type="brave.propagation.Propagation.Setter"/>
    </method>
    <method name="extractor" return="brave.propagation.TraceContext.Extractor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="getter" type="brave.propagation.Propagation.Getter"/>
    </method>
    <doc>
    <![CDATA[This implements in-process and remote {@linkplain BaggageField baggage} propagation.

 <p>For example, if you have a need to know the a specific request's country code, you can
 propagate it through the trace as HTTP headers.
 <pre>{@code
 import brave.baggage.BaggagePropagationConfig.SingleBaggageField;

 // Configure your baggage field
 COUNTRY_CODE = BaggageField.create("country-code");

 // When you initialize the builder, add the baggage you want to propagate
 tracingBuilder.propagationFactory(
   BaggagePropagation.newFactoryBuilder(B3Propagation.FACTORY)
                     .add(SingleBaggageField.remote(COUNTRY_CODE))
                     .build()
 );

 // later, you can tag that country code
 Tags.BAGGAGE_FIELD.tag(COUNTRY_CODE, span);
 }</pre>

 <p>See {@link BaggageField} for baggage usage examples.

 <h3>Customizing propagation keys</h3>
 {@link SingleBaggageField#remote(BaggageField)} sets the name used as a propagation key (header)
 to the lowercase variant of the field name. You can override this by supplying different key
 names. Note: they will be lower-cased.

 <p>For example, the following will propagate the field "x-vcap-request-id" as-is, but send the
 fields "countryCode" and "userId" on the wire as "baggage-country-code" and "baggage-user-id"
 respectively.

 <pre>{@code
 import brave.baggage.BaggagePropagationConfig.SingleBaggageField;

 REQUEST_ID = BaggageField.create("x-vcap-request-id");
 COUNTRY_CODE = BaggageField.create("countryCode");
 USER_ID = BaggageField.create("userId");

 tracingBuilder.propagationFactory(
     BaggagePropagation.newFactoryBuilder(B3Propagation.FACTORY)
                       .add(SingleBaggageField.remote(REQUEST_ID))
                       .add(SingleBaggageField.newBuilder(COUNTRY_CODE)
                                              .addKeyName("baggage-country-code").build())
                       .add(SingleBaggageField.newBuilder(USER_ID)
                                              .addKeyName("baggage-user-id").build())
                       .build()
 );
 }</pre>

 @see BaggageField
 @see BaggagePropagationConfig
 @see BaggagePropagationCustomizer
 @see CorrelationScopeDecorator
 @since 5.11]]>
    </doc>
  </class>
  <!-- end class brave.baggage.BaggagePropagation -->
  <!-- start class brave.baggage.BaggagePropagation.FactoryBuilder -->
  <class name="BaggagePropagation.FactoryBuilder" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="configs" return="java.util.Set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an immutable copy of the current {@linkplain #add(BaggagePropagationConfig)
 configuration}. This allows those who can't create the builder to reconfigure this builder.

 @see #clear()
 @since 5.11]]>
      </doc>
    </method>
    <method name="clear" return="brave.baggage.BaggagePropagation.FactoryBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Clears all state. This allows those who can't create the builder to reconfigure fields.

 @see #configs()
 @see BaggagePropagationCustomizer
 @since 5.11]]>
      </doc>
    </method>
    <method name="add" return="brave.baggage.BaggagePropagation.FactoryBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="brave.baggage.BaggagePropagationConfig"/>
      <doc>
      <![CDATA[@since 5.11]]>
      </doc>
    </method>
    <method name="build" return="brave.propagation.Propagation.Factory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the delegate if there are no fields to propagate.]]>
      </doc>
    </method>
  </class>
  <!-- end class brave.baggage.BaggagePropagation.FactoryBuilder -->
  <!-- start class brave.baggage.BaggagePropagationConfig -->
  <class name="BaggagePropagationConfig" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <doc>
    <![CDATA[Holds {@link BaggagePropagation} configuration.

 <h3>Field mapping</h3>
 Your log correlation properties may not be the same as the baggage field names. You can override
 them with the builder as needed.

 <p>Ex. If your log property is %X{trace-id}, you can do this:
 <pre>{@code
 import brave.baggage.BaggagePropagationConfig.SingleBaggageField;

 scopeBuilder.clear() // TRACE_ID is a default field!
             .add(SingleBaggageField.newBuilder(BaggageFields.TRACE_ID)
                                        .name("trace-id").build())
 }</pre>

 <p><em>Note</em>At the moment, dynamic fields are not supported. Use {@link
 SingleBaggageField} for each field you need to propagate.

 @see BaggagePropagation
 @see BaggageField
 @see BaggagePropagationConfig
 @see BaggagePropagationCustomizer
 @since 5.11]]>
    </doc>
  </class>
  <!-- end class brave.baggage.BaggagePropagationConfig -->
  <!-- start class brave.baggage.BaggagePropagationConfig.SingleBaggageField -->
  <class name="BaggagePropagationConfig.SingleBaggageField" extends="brave.baggage.BaggagePropagationConfig"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="local" return="brave.baggage.BaggagePropagationConfig.SingleBaggageField"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="field" type="brave.baggage.BaggageField"/>
      <doc>
      <![CDATA[Configures this field for only local propagation. This will not be read from or written to
 remote headers.

 @see #remote(BaggageField)
 @since 5.11]]>
      </doc>
    </method>
    <method name="remote" return="brave.baggage.BaggagePropagationConfig.SingleBaggageField"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="field" type="brave.baggage.BaggageField"/>
      <doc>
      <![CDATA[Configures this field for remote propagation using its lower-case {@link BaggageField#name()}
 as the only {@linkplain #keyNames() propagation key name}.

 @see #local(BaggageField)
 @see #newBuilder(BaggageField) to use different propagation key names.]]>
      </doc>
    </method>
    <method name="newBuilder" return="brave.baggage.BaggagePropagationConfig.SingleBaggageField.Builder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="field" type="brave.baggage.BaggageField"/>
      <doc>
      <![CDATA[@since 5.11]]>
      </doc>
    </method>
    <method name="toBuilder" return="brave.baggage.BaggagePropagationConfig.SingleBaggageField.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Allows decorators to reconfigure correlation of this {@link #field()}

 @see BaggagePropagationCustomizer
 @since 5.11]]>
      </doc>
    </method>
    <method name="field" return="brave.baggage.BaggageField"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="keyNames" return="java.util.Set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a possibly empty list of lower-case {@link Propagation#keys() propagation key names}.
 When empty, the field is not propagated remotely.

 @since 5.11]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns true for any config with the same baggage field.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the same value for any config with the same baggage field.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Holds {@link BaggagePropagation} configuration for a {@linkplain BaggageField baggage field}.

 @see BaggagePropagation
 @see BaggageField
 @since 5.11]]>
    </doc>
  </class>
  <!-- end class brave.baggage.BaggagePropagationConfig.SingleBaggageField -->
  <!-- start class brave.baggage.BaggagePropagationConfig.SingleBaggageField.Builder -->
  <class name="BaggagePropagationConfig.SingleBaggageField.Builder" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="addKeyName" return="brave.baggage.BaggagePropagationConfig.SingleBaggageField.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keyName" type="java.lang.String"/>
      <doc>
      <![CDATA[Configures a {@linkplain Propagation#keys() key name} for remote propagation.

 @see SingleBaggageField#keyNames()
 @since 5.11]]>
      </doc>
    </method>
    <method name="build" return="brave.baggage.BaggagePropagationConfig.SingleBaggageField"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@since 5.11]]>
      </doc>
    </method>
    <doc>
    <![CDATA[@since 5.11]]>
    </doc>
  </class>
  <!-- end class brave.baggage.BaggagePropagationConfig.SingleBaggageField.Builder -->
  <!-- start interface brave.baggage.BaggagePropagationCustomizer -->
  <interface name="BaggagePropagationCustomizer"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="customize"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="builder" type="brave.baggage.BaggagePropagation.FactoryBuilder"/>
    </method>
    <field name="NOOP" type="brave.baggage.BaggagePropagationCustomizer"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Use to avoid comparing against null references]]>
      </doc>
    </field>
    <doc>
    <![CDATA[This allows configuration plugins to collaborate on building an instance of {@link
 BaggagePropagation.Factory}.

 <p>For example, a customizer can {@link BaggagePropagation.FactoryBuilder#add(BaggagePropagationConfig)
 add a baggage field} without affecting the {@link BaggagePropagation#newFactoryBuilder(Propagation.Factory)
 trace propagation format}.

 <p>This also allows one object to customize both {@linkplain BaggagePropagation baggage}
 and {@link CorrelationScopeDecorator correlation integration}, by implementing both customizer
 interfaces.

 <h3>Integration examples</h3>

 <p>In practice, a dependency injection tool applies a collection of these instances prior to
 {@link BaggagePropagation.FactoryBuilder#build() building the baggage propagation instance}. For
 example, an injected {@code List<BaggagePropagationCustomizer>} parameter to a provider of {@link
 Propagation.Factory}.

 <p>Here are some examples, in alphabetical order:
 <pre><ul>
   <li><a href="https://dagger.dev/multibindings.html">Dagger Set Multibindings</a></li>
   <li><a href="http://google.github.io/guice/api-docs/latest/javadoc/com/google/inject/multibindings/Multibinder.html">Guice Set Multibinder</a></li>
   <li><a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-autowired-annotation">Spring Autowired Collections</a></li>
 </ul></pre>

 @see CorrelationScopeCustomizer
 @see BaggagePropagationConfig
 @since 5.11]]>
    </doc>
  </interface>
  <!-- end interface brave.baggage.BaggagePropagationCustomizer -->
  <!-- start class brave.baggage.CorrelationScopeConfig -->
  <class name="CorrelationScopeConfig" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <doc>
    <![CDATA[Holds {@link CorrelationScopeDecorator} configuration.

 <h3>Field mapping</h3>
 Your log correlation properties may not be the same as the baggage field names. You can override
 them with the builder as needed.

 <p>Ex. If your log property is %X{trace-id}, you can do this:
 <pre>{@code
 import brave.baggage.CorrelationScopeConfig.SingleCorrelationField;

 scopeBuilder.clear() // TRACE_ID is a default field!
             .add(SingleCorrelationField.newBuilder(BaggageFields.TRACE_ID)
                                        .name("trace-id").build())
 }</pre>

 <p><em>Note</em>At the moment, dynamic fields are not supported. Use {@link
 SingleCorrelationField} for each field you need in the correlation context.

 @see CorrelationScopeDecorator
 @see BaggageField
 @since 5.11]]>
    </doc>
  </class>
  <!-- end class brave.baggage.CorrelationScopeConfig -->
  <!-- start class brave.baggage.CorrelationScopeConfig.SingleCorrelationField -->
  <class name="CorrelationScopeConfig.SingleCorrelationField" extends="brave.baggage.CorrelationScopeConfig"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="create" return="brave.baggage.CorrelationScopeConfig.SingleCorrelationField"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="baggageField" type="brave.baggage.BaggageField"/>
      <doc>
      <![CDATA[@since 5.11]]>
      </doc>
    </method>
    <method name="newBuilder" return="brave.baggage.CorrelationScopeConfig.SingleCorrelationField.Builder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="baggageField" type="brave.baggage.BaggageField"/>
      <doc>
      <![CDATA[@since 5.11]]>
      </doc>
    </method>
    <method name="toBuilder" return="brave.baggage.CorrelationScopeConfig.SingleCorrelationField.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Allows decorators to reconfigure correlation of this {@link #baggageField()}

 @see CorrelationScopeCustomizer
 @since 5.11]]>
      </doc>
    </method>
    <method name="baggageField" return="brave.baggage.BaggageField"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="name" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The name to use in the correlation context. This defaults to {@link BaggageField#name()}
 unless overridden by {@link Builder#name(String)}.

 @since 5.11]]>
      </doc>
    </method>
    <method name="dirty" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Adds a name in the underlying context which is updated directly. The decorator will overwrite
 any underlying changes when the scope closes.

 <p>This is used when there are a mix of libraries controlling the same correlation field.
 For example, if SLF4J MDC can update the same field name.

 <p>This has a similar performance impact to {@link #flushOnUpdate()}, as it requires
 tracking the field value even if there's no change detected.

 @since 5.11]]>
      </doc>
    </method>
    <method name="flushOnUpdate" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[When true, updates made to this name via {@linkplain BaggageField#updateValue(TraceContext,
 String)} flush immediately to the correlation context.

 <p>This is useful for callbacks that have a void return. Ex.
 <pre>{@code
 @SendTo(SourceChannels.OUTPUT)
 public void timerMessageSource() {
   // Assume BUSINESS_PROCESS is an updatable field
   BUSINESS_PROCESS.updateValue("accounting");
   // Assuming a Log4j context, the expression %{bp} will show "accounting" in businessCode()
   businessCode();
 }
 }</pre>

 <h3>Appropriate Usage</h3>
 This has a significant performance impact as it requires even {@link
 CurrentTraceContext#maybeScope(TraceContext)} to always track values.

 <p>Most fields do not change in the scope of a {@link TraceContext}. For example, standard
 fields such as {@link BaggageFields#SPAN_ID the span ID} and {@linkplain
 BaggageFields#constant(String, String) constants} such as env variables do not need to be
 tracked. Even field value updates do not necessarily need to be flushed to the underlying
 correlation context, as they will apply on the next scope operation.

 @since 5.11]]>
      </doc>
    </method>
    <method name="readOnly" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns true if this value is immutable within a {@link TraceContext}.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns true for any config with the same baggage field.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the same value for any config with the same baggage field.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Holds {@link CorrelationScopeDecorator} configuration for a {@linkplain BaggageField baggage
 field}.

 <h3>Visibility</h3>
 <p>By default, field updates only apply during {@linkplain CorrelationScopeDecorator scope
 decoration}. This means values set do not flush immediately to the underlying correlation
 context. Rather, they are scheduled for the next scope operation as a way to control overhead.
 {@link SingleCorrelationField#flushOnUpdate()} overrides this.

 @see CorrelationScopeDecorator
 @see BaggageField
 @since 5.11]]>
    </doc>
  </class>
  <!-- end class brave.baggage.CorrelationScopeConfig.SingleCorrelationField -->
  <!-- start class brave.baggage.CorrelationScopeConfig.SingleCorrelationField.Builder -->
  <class name="CorrelationScopeConfig.SingleCorrelationField.Builder" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="name" return="brave.baggage.CorrelationScopeConfig.SingleCorrelationField.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[@see SingleCorrelationField#name()]]>
      </doc>
    </method>
    <method name="dirty" return="brave.baggage.CorrelationScopeConfig.SingleCorrelationField.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see SingleCorrelationField#dirty()]]>
      </doc>
    </method>
    <method name="flushOnUpdate" return="brave.baggage.CorrelationScopeConfig.SingleCorrelationField.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see SingleCorrelationField#flushOnUpdate()]]>
      </doc>
    </method>
    <method name="build" return="brave.baggage.CorrelationScopeConfig.SingleCorrelationField"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@since 5.11]]>
      </doc>
    </method>
    <doc>
    <![CDATA[@since 5.11]]>
    </doc>
  </class>
  <!-- end class brave.baggage.CorrelationScopeConfig.SingleCorrelationField.Builder -->
  <!-- start interface brave.baggage.CorrelationScopeCustomizer -->
  <interface name="CorrelationScopeCustomizer"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="customize"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="builder" type="brave.baggage.CorrelationScopeDecorator.Builder"/>
    </method>
    <field name="NOOP" type="brave.baggage.CorrelationScopeCustomizer"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Use to avoid comparing against null references]]>
      </doc>
    </field>
    <doc>
    <![CDATA[This allows configuration plugins to collaborate on building an instance of {@link
 CorrelationScopeDecorator}.

 <p>For example, a customizer can {@linkplain CorrelationScopeDecorator.Builder#add(CorrelationScopeConfig)
 configure a baggage field} without instantiating the {@link CorrelationScopeDecorator.Builder).

 <p>This also allows one object to customize both {@linkplain BaggagePropagation baggage}
 and {@link CorrelationScopeDecorator correlation integration}, by implementing both customizer
 interfaces.

 <h3>Integration examples</h3>

 <p>In practice, a dependency injection tool applies a collection of these instances prior to
 {@link CorrelationScopeDecorator.Builder#build() building the scope instance}. For example, an
 injected {@code List<CorrelationCustomizer>} parameter to a provider of {@link
 Propagation.Factory }.

 <p>Here are some examples, in alphabetical order:
 <pre><ul>
   <li><a href="https://dagger.dev/multibindings.html">Dagger Set Multibindings</a></li>
   <li><a href="http://google.github.io/guice/api-docs/latest/javadoc/com/google/inject/multibindings/Multibinder.html">Guice Set Multibinder</a></li>
   <li><a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-autowired-annotation">Spring Autowired Collections</a></li>
 </ul></pre>

 @see CorrelationScopeConfig
 @see BaggageCustomizer
 @since 5.11]]>
    </doc>
  </interface>
  <!-- end interface brave.baggage.CorrelationScopeCustomizer -->
  <!-- start class brave.baggage.CorrelationScopeDecorator -->
  <class name="CorrelationScopeDecorator" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="brave.propagation.CurrentTraceContext.ScopeDecorator"/>
    <doc>
    <![CDATA[Synchronizes fields such as {@link BaggageFields#TRACE_ID} with a correlation context, such as
 logging through decoration of a scope. A maximum of 32 fields are supported.

 <p>Setup example:
 <pre>{@code
 import brave.baggage.CorrelationScopeConfig.SingleCorrelationField;

 // Add the field "region", so it can be used as a log expression %X{region}
 CLOUD_REGION = BaggageFields.constant("region", System.getEnv("CLOUD_REGION"));

 decorator = MDCScopeDecorator.newBuilder()
                              .add(SingleCorrelationField.create(CLOUD_REGION))
                              .build();

 // Integrate the decorator
 tracing = Tracing.newBuilder()
                  .currentTraceContext(ThreadLocalCurrentTraceContext.newBuilder()
                    .addScopeDecorator(decorator)
                    .build())
                  ...
                  .build();

 // Any scope operations (updates to the current span) apply the fields defined by the decorator.
 ScopedSpan span = tracing.tracer().startScopedSpan("encode");
 try {
   // The below log message will have %X{region} in the context!
   logger.info("Encoding the span, hope it works");
   return encoder.encode();
 } catch (RuntimeException | Error e) {
   span.error(e); // Unless you handle exceptions, you might not know the operation failed!
   throw e;
 } finally {
   span.finish();
 }
 }</pre>

 @see CorrelationScopeConfig
 @see CorrelationScopeCustomizer
 @see BaggagePropagation
 @since 5.11]]>
    </doc>
  </class>
  <!-- end class brave.baggage.CorrelationScopeDecorator -->
  <!-- start class brave.baggage.CorrelationScopeDecorator.Builder -->
  <class name="CorrelationScopeDecorator.Builder" extends="java.lang.Object"
    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Builder" type="brave.internal.CorrelationContext"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Internal constructor used by subtypes.]]>
      </doc>
    </constructor>
    <method name="configs" return="java.util.Set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an immutable copy of the current {@linkplain #add(CorrelationScopeConfig)
 configuration}. This allows those who can't create the builder to reconfigure this builder.

 @see #clear()
 @since 5.11]]>
      </doc>
    </method>
    <method name="clear" return="brave.baggage.CorrelationScopeDecorator.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Invoke this to clear fields so that you can {@linkplain #add(CorrelationScopeConfig) add the
 ones you need}.

 <p>Defaults may include a field you aren't using, such as {@link BaggageFields#PARENT_ID}.
 For best performance, only include the fields you use in your correlation expressions (such
 as log formats).

 @see #configs()
 @see CorrelationScopeDecorator
 @since 5.11]]>
      </doc>
    </method>
    <method name="add" return="brave.baggage.CorrelationScopeDecorator.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="brave.baggage.CorrelationScopeConfig"/>
      <doc>
      <![CDATA[@since 5.11]]>
      </doc>
    </method>
    <method name="build" return="brave.propagation.CurrentTraceContext.ScopeDecorator"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return {@link ScopeDecorator#NOOP} if no baggage fields were added.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Defaults to {@link BaggageFields#TRACE_ID} and {@link BaggageFields#SPAN_ID}.]]>
    </doc>
  </class>
  <!-- end class brave.baggage.CorrelationScopeDecorator.Builder -->
</package>
<package name="brave.handler">
  <!-- start class brave.handler.FinishedSpanHandler -->
  <class name="FinishedSpanHandler" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="FinishedSpanHandler"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="handle" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="context" type="brave.propagation.TraceContext"/>
      <param name="span" type="brave.handler.MutableSpan"/>
      <doc>
      <![CDATA[This is invoked after a span is finished, allowing data to be modified or reported out of
 process. A return value of false means the span should be dropped completely from the stream.

 <p>Changes to the input span are visible by later finished span handlers. One reason to change
 the input is to align tags, so that correlation occurs. For example, some may clean the tag
 "http.path" knowing downstream handlers such as zipkin reporting have the same value.

 <p>Returning false is the same effect as if {@link Span#abandon()} was called. Implementations
 should be careful when returning false as it can lead to broken traces. Acceptable use cases
 are when the span is a leaf, for example a client call to an uninstrumented database, or a
 server call which is known to terminate in-process (for example, health-checks). Prefer an
 instrumentation policy approach to this mechanism as it results in less overhead.

 <p>Implementations should not hold a reference to it after this method returns. This is to
 allow object recycling.

 @param context the trace context which is {@link TraceContext#sampled()} or {@link
 TraceContext#sampledLocal()}. This includes identifiers and potentially {@link
 TraceContext#extra() extra propagated data} such as extended sampling configuration.
 @param span a mutable object including all data recorded with span apis. Modifications are
 visible to later handlers, including Zipkin.
 @return true retains the span, and should almost always be used. false drops the span, making
 it invisible to later handlers such as Zipkin.
 @see #supportsOrphans() If you are scrubbing personal information, consider supporting orphans.
 @see Tag#tag(Object, TraceContext, MutableSpan)]]>
      </doc>
    </method>
    <method name="supportsOrphans" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Normally, {@link #handle(TraceContext, MutableSpan)} is only called upon explicit termination
 of a span: {@link Span#finish()}, {@link Span#finish(long)} or {@link Span#flush()}. When this
 method returns true, the callback will also receive data orphaned due to spans being never
 terminated or data added after termination. It is important to understand this, especially if
 your handler is performing work like redaction. This sort of work needs to happen on all data,
 not just the success paths.

 <h3>What is an orphaned span?</h3>

 <p>Brave adds an {@link Span#annotate(String) annotation} "brave.flush" when data remains
 associated with a span when it is garbage collected. This is almost always a bug. For example,
 calling {@link Span#tag(String, String)} after calling {@link Span#finish()}, or calling {@link
 Tracer#nextSpan()} yet never using the result. To track down bugs like this, set the logger
 {@link PendingSpans} to FINE level.

 <h3>Why handle orphaned spans?</h3>

 <p>Use cases for handling orphans include redaction, trimming the "brave.flush" annotation,
 logging a different way than default, or incrementing bug counters. For example, you could use
 the same credit card cleaner here as you do on the success path.

 <h3>What shouldn't handle orphaned spans?</h3>

 <p>As this is related to bugs, no assumptions can be made about span count etc. For example,
 one span context can result in many calls to this handler, unrelated to the actual operation
 performed. Handlers that redact or clean data work for normal spans and orphans. However,
 aggregation handlers, such as dependency linkers or success/fail counters, can create problems
 if used against orphaned spans.

 <h2>Implementation</h2>

 <p>By default, this method returns false, suggesting the implementation is not designed to
 also process orphans. Return true to indicate otherwise. Whichever choice should be constant.
 In other words do not sometimes return false and other times true, as the value is only read
 once.

 <h3>Considerations for implementing {@code handle}</h3>

 <p>When this method returns true, the {@link #handle(TraceContext, MutableSpan) handle method}
 is both invoked for normal spans and also orphaned ones. The following apply when handling
 orphans:

 <p>The {@link TraceContext} parameter contains minimal information, including lookup ids
 (traceId, spanId and localRootId) and sampling status. {@link TraceContext#extra() "extra"}
 will be empty.

 <p>The {@link MutableSpan} parameter {@link MutableSpan#containsAnnotation(String) includes
 the annotation} "brave.flush", and whatever state was orphaned (ex a tag).

 @since 5.7]]>
      </doc>
    </method>
    <method name="alwaysSampleLocal" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[When true, all spans become real spans even if they aren't sampled remotely. This allows
 finished span handlers (such as metrics) to consider attributes that are not always visible
 before-the-fact, such as http paths. Defaults to false and affects {@link
 TraceContext#sampledLocal()}.

 @see #handle(TraceContext, MutableSpan)]]>
      </doc>
    </method>
    <field name="NOOP" type="brave.handler.FinishedSpanHandler"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Use to avoid comparing against null references]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Triggered on each finished span except when spans that are {@link Span#isNoop() no-op}.

 <p>{@link TraceContext#sampled() Sampled spans} hit this stage before reporting to Zipkin.
 This means changes to the mutable span will reflect in reported data.

 <p>When Zipkin's reporter is {@link zipkin2.reporter.Reporter#NOOP} or the context is
 unsampled, this will still receive spans where {@link TraceContext#sampledLocal()} is true.

 @see #alwaysSampleLocal()
 @since 5.4]]>
    </doc>
  </class>
  <!-- end class brave.handler.FinishedSpanHandler -->
  <!-- start class brave.handler.MutableSpan -->
  <class name="MutableSpan" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.Cloneable"/>
    <constructor name="MutableSpan"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="isEmpty" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns true if there was no data added. Usually this indicates an instrumentation bug.]]>
      </doc>
    </method>
    <method name="name" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the {@link brave.Span#name(String) span name} or null]]>
      </doc>
    </method>
    <method name="name"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[@see brave.Span#name(String)]]>
      </doc>
    </method>
    <method name="startTimestamp" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the {@link brave.Span#start(long) span start timestamp} or zero]]>
      </doc>
    </method>
    <method name="startTimestamp"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="startTimestamp" type="long"/>
      <doc>
      <![CDATA[@see brave.Span#start(long)]]>
      </doc>
    </method>
    <method name="finishTimestamp" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the {@link brave.Span#finish(long) span finish timestamp} or zero]]>
      </doc>
    </method>
    <method name="finishTimestamp"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="finishTimestamp" type="long"/>
      <doc>
      <![CDATA[@see brave.Span#finish(long)]]>
      </doc>
    </method>
    <method name="kind" return="brave.Span.Kind"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the {@link brave.Span#kind(brave.Span.Kind) span kind} or null]]>
      </doc>
    </method>
    <method name="kind"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="kind" type="brave.Span.Kind"/>
      <doc>
      <![CDATA[@see brave.Span#kind(brave.Span.Kind)]]>
      </doc>
    </method>
    <method name="localServiceName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[When null {@link brave.Tracing.Builder#localServiceName(String) default} is used.]]>
      </doc>
    </method>
    <method name="localServiceName"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="localServiceName" type="java.lang.String"/>
      <doc>
      <![CDATA[@see brave.Tracing.Builder#localServiceName(String)]]>
      </doc>
    </method>
    <method name="localIp" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[When null {@link brave.Tracing.Builder#localIp(String) default} will be used for zipkin.]]>
      </doc>
    </method>
    <method name="localIp" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="localIp" type="java.lang.String"/>
      <doc>
      <![CDATA[@see #localIp()]]>
      </doc>
    </method>
    <method name="localPort" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[When zero {@link brave.Tracing.Builder#localIp(String) default} will be used for zipkin.]]>
      </doc>
    </method>
    <method name="localPort"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="localPort" type="int"/>
      <doc>
      <![CDATA[@see #localPort()]]>
      </doc>
    </method>
    <method name="remoteServiceName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see brave.Span#remoteServiceName(String)]]>
      </doc>
    </method>
    <method name="remoteServiceName"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="remoteServiceName" type="java.lang.String"/>
      <doc>
      <![CDATA[@see brave.Span#remoteServiceName(String)]]>
      </doc>
    </method>
    <method name="remoteIp" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The text representation of the primary IPv4 or IPv6 address associated with the remote side of
 this connection. Ex. 192.168.99.100 null if unknown.

 @see brave.Span#remoteIpAndPort(String, int)]]>
      </doc>
    </method>
    <method name="remotePort" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Port of the remote IP's socket or 0, if not known.

 @see java.net.InetSocketAddress#getPort()
 @see brave.Span#remoteIpAndPort(String, int)]]>
      </doc>
    </method>
    <method name="remoteIpAndPort" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="remoteIp" type="java.lang.String"/>
      <param name="remotePort" type="int"/>
      <doc>
      <![CDATA[@see brave.Span#remoteIpAndPort(String, int)]]>
      </doc>
    </method>
    <method name="containsAnnotation" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns true if an annotation with the given value exists in this span.]]>
      </doc>
    </method>
    <method name="annotate"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timestamp" type="long"/>
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[@see brave.Span#annotate(String)]]>
      </doc>
    </method>
    <method name="error" return="java.lang.Throwable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see brave.Span#error(Throwable)]]>
      </doc>
    </method>
    <method name="error"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="error" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[@see brave.Span#error(Throwable)]]>
      </doc>
    </method>
    <method name="tag" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns the last value associated with the key or null]]>
      </doc>
    </method>
    <method name="tag"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[@see brave.Span#tag(String, String)
 @see Tag#tag(Object, TraceContext, MutableSpan)]]>
      </doc>
    </method>
    <method name="forEachTag"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tagConsumer" type="brave.handler.MutableSpan.TagConsumer"/>
      <param name="target" type="java.lang.Object"/>
    </method>
    <method name="forEachTag"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tagUpdater" type="brave.handler.MutableSpan.TagUpdater"/>
      <doc>
      <![CDATA[Allows you to update values for redaction purposes]]>
      </doc>
    </method>
    <method name="forEachAnnotation"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="annotationConsumer" type="brave.handler.MutableSpan.AnnotationConsumer"/>
      <param name="target" type="java.lang.Object"/>
      <doc>
      <![CDATA[Allows you to copy all data into a different target, such as a different span model or logs.]]>
      </doc>
    </method>
    <method name="forEachAnnotation"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="annotationUpdater" type="brave.handler.MutableSpan.AnnotationUpdater"/>
      <doc>
      <![CDATA[Allows you to update values for redaction purposes]]>
      </doc>
    </method>
    <method name="shared" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns true if the span ID is {@link #setShared() shared} with a remote client.]]>
      </doc>
    </method>
    <method name="setShared"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Indicates we are contributing to a span started by another tracer (ex on a different host).
 Defaults to false.

 @see Tracer#joinSpan(TraceContext)
 @see zipkin2.Span#shared()]]>
      </doc>
    </method>
    <doc>
    <![CDATA[This represents a span except for its {@link TraceContext}. It is mutable, for late adjustments.

 <p>While in-flight, the data is synchronized where necessary. When exposed to users, it can be
 mutated without synchronization.]]>
    </doc>
  </class>
  <!-- end class brave.handler.MutableSpan -->
  <!-- start interface brave.handler.MutableSpan.AnnotationConsumer -->
  <interface name="MutableSpan.AnnotationConsumer"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="accept"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="target" type="java.lang.Object"/>
      <param name="timestamp" type="long"/>
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[@see brave.Span#annotate(long, String)]]>
      </doc>
    </method>
  </interface>
  <!-- end interface brave.handler.MutableSpan.AnnotationConsumer -->
  <!-- start interface brave.handler.MutableSpan.AnnotationUpdater -->
  <interface name="MutableSpan.AnnotationUpdater"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="update" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timestamp" type="long"/>
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns the same value, an updated one, or null to drop the annotation.

 @see brave.Span#annotate(long, String)]]>
      </doc>
    </method>
  </interface>
  <!-- end interface brave.handler.MutableSpan.AnnotationUpdater -->
  <!-- start interface brave.handler.MutableSpan.TagConsumer -->
  <interface name="MutableSpan.TagConsumer"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="accept"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="target" type="java.lang.Object"/>
      <param name="key" type="java.lang.String"/>
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[@see brave.Span#tag(String, String)]]>
      </doc>
    </method>
  </interface>
  <!-- end interface brave.handler.MutableSpan.TagConsumer -->
  <!-- start interface brave.handler.MutableSpan.TagUpdater -->
  <interface name="MutableSpan.TagUpdater"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="update" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns the same value, an updated one, or null to drop the tag.

 @see brave.Span#tag(String, String)]]>
      </doc>
    </method>
  </interface>
  <!-- end interface brave.handler.MutableSpan.TagUpdater -->
</package>
<package name="brave.propagation">
  <!-- start class brave.propagation.B3Propagation -->
  <class name="B3Propagation" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="brave.propagation.Propagation"/>
    <method name="newFactoryBuilder" return="brave.propagation.B3Propagation.FactoryBuilder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="keys" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="injector" return="brave.propagation.TraceContext.Injector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="setter" type="brave.propagation.Propagation.Setter"/>
    </method>
    <method name="extractor" return="brave.propagation.TraceContext.Extractor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="getter" type="brave.propagation.Propagation.Getter"/>
    </method>
    <field name="FACTORY" type="brave.propagation.Propagation.Factory"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Implements <a href="https://github.com/openzipkin/b3-propagation">B3 Propagation</a>]]>
    </doc>
  </class>
  <!-- end class brave.propagation.B3Propagation -->
  <!-- start class brave.propagation.B3Propagation.FactoryBuilder -->
  <class name="B3Propagation.FactoryBuilder" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="injectFormat" return="brave.propagation.B3Propagation.FactoryBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="format" type="brave.propagation.B3Propagation.Format"/>
      <doc>
      <![CDATA[Overrides the default format of {@link Format#MULTI}.]]>
      </doc>
    </method>
    <method name="injectFormat" return="brave.propagation.B3Propagation.FactoryBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="kind" type="brave.Span.Kind"/>
      <param name="format" type="brave.propagation.B3Propagation.Format"/>
      <doc>
      <![CDATA[Overrides the injection format used for the indicated {@link Request#spanKind() span kind}.]]>
      </doc>
    </method>
    <method name="injectFormats" return="brave.propagation.B3Propagation.FactoryBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="kind" type="brave.Span.Kind"/>
      <param name="format1" type="brave.propagation.B3Propagation.Format"/>
      <param name="format2" type="brave.propagation.B3Propagation.Format"/>
      <doc>
      <![CDATA[Like {@link #injectFormat}, but writes two formats.

 For example, you can set {@link Span.Kind#CLIENT} spans to inject both {@link Format#MULTI}
 and {@link Format#SINGLE}, for transition use cases.]]>
      </doc>
    </method>
    <method name="build" return="brave.propagation.Propagation.Factory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Defaults to {@link Format#MULTI} for client/server spans and {@link Format#SINGLE_NO_PARENT}
 for messaging. Non-request spans default to {@link Format#MULTI}.]]>
    </doc>
  </class>
  <!-- end class brave.propagation.B3Propagation.FactoryBuilder -->
  <!-- start class brave.propagation.B3Propagation.Format -->
  <class name="B3Propagation.Format" extends="java.lang.Enum"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="brave.propagation.B3Propagation.Format[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="brave.propagation.B3Propagation.Format"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <field name="MULTI" type="brave.propagation.B3Propagation.Format"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The trace context is encoded with a several fields prefixed with "x-b3-".]]>
      </doc>
    </field>
    <field name="SINGLE" type="brave.propagation.B3Propagation.Format"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The trace context is encoded with {@link B3SingleFormat#writeB3SingleFormat(TraceContext)}.]]>
      </doc>
    </field>
    <field name="SINGLE_NO_PARENT" type="brave.propagation.B3Propagation.Format"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The trace context is encoded with {@link B3SingleFormat#writeB3SingleFormatWithoutParentId(TraceContext)}.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Describes the formats used to inject headers.]]>
    </doc>
  </class>
  <!-- end class brave.propagation.B3Propagation.Format -->
  <!-- start class brave.propagation.B3SingleFormat -->
  <class name="B3SingleFormat" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="writeB3SingleFormatWithoutParentId" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="context" type="brave.propagation.TraceContext"/>
      <doc>
      <![CDATA[Writes all B3 defined fields in the trace context, except {@link TraceContext#parentIdAsLong()
 parent ID}, to a hyphen delimited string.

 <p>This is appropriate for receivers who understand "b3" single header format, and always do
 work in a child span. For example, message consumers always do work in child spans, so message
 producers can use this format to save bytes on the wire. On the other hand, RPC clients should
 use {@link #writeB3SingleFormat(TraceContext)} instead, as RPC servers often share a span ID
 with the client.]]>
      </doc>
    </method>
    <method name="writeB3SingleFormatWithoutParentIdAsBytes" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="context" type="brave.propagation.TraceContext"/>
      <doc>
      <![CDATA[Like {@link #writeB3SingleFormatWithoutParentId(TraceContext)}, but for carriers with byte
 array or byte buffer values. For example, {@link ByteBuffer#wrap(byte[])} can wrap the result.]]>
      </doc>
    </method>
    <method name="writeB3SingleFormat" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="context" type="brave.propagation.TraceContext"/>
      <doc>
      <![CDATA[Writes all B3 defined fields in the trace context to a hyphen delimited string. This is
 appropriate for receivers who understand "b3" single header format.

 <p>The {@link TraceContext#parentIdAsLong() parent ID} is serialized in case the receiver is
 an RPC server. When downstream is known to be a messaging consumer, or a server that never
 reuses a client's span ID, prefer {@link #writeB3SingleFormatWithoutParentId(TraceContext)}.]]>
      </doc>
    </method>
    <method name="writeB3SingleFormatAsBytes" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="context" type="brave.propagation.TraceContext"/>
      <doc>
      <![CDATA[Like {@link #writeB3SingleFormat(TraceContext)}, but for carriers with byte array or byte
 buffer values. For example, {@link ByteBuffer#wrap(byte[])} can wrap the result.]]>
      </doc>
    </method>
    <method name="parseB3SingleFormat" return="brave.propagation.TraceContextOrSamplingFlags"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b3" type="java.lang.CharSequence"/>
    </method>
    <method name="parseB3SingleFormat" return="brave.propagation.TraceContextOrSamplingFlags"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.CharSequence"/>
      <param name="beginIndex" type="int"/>
      <param name="endIndex" type="int"/>
      <doc>
      <![CDATA[This reads a trace context a sequence potentially larger than the format. The use-case is
 reducing garbage, by re-using the input {@code value} across multiple parse operations.

 @param value the sequence that contains a B3 single formatted trace context
 @param beginIndex the inclusive begin index: {@linkplain CharSequence#charAt(int) index} of the
 first character in B3 single format.
 @param endIndex the exclusive end index: {@linkplain CharSequence#charAt(int) index}
 <em>after</em> the last character in B3 single format.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[This format corresponds to the propagation key "b3" (or "B3"), which delimits fields in the
 following manner.

 <pre>{@code
 b3: {x-b3-traceid}-{x-b3-spanid}-{if x-b3-flags 'd' else x-b3-sampled}-{x-b3-parentspanid}
 }</pre>

 <p>For example, a sampled root span would look like:
 {@code 4bf92f3577b34da6a3ce929d0e0e4736-00f067aa0ba902b7-1}

 <p>... a not yet sampled root span would look like:
 {@code 4bf92f3577b34da6a3ce929d0e0e4736-00f067aa0ba902b7}

 <p>... and a debug RPC child span would look like:
 {@code 4bf92f3577b34da6a3ce929d0e0e4736-00f067aa0ba902b7-d-5b4185666d50f68b}

 <p>Like normal B3, it is valid to omit trace identifiers in order to only propagate a sampling
 decision. For example, the following are valid downstream hints:
 <ul>
 <li>don't sample - {@code b3: 0}</li>
 <li>sampled - {@code b3: 1}</li>
 <li>debug - {@code b3: d}</li>
 </ul>

 Reminder: debug (previously {@code X-B3-Flags: 1}), is a boosted sample signal which is recorded
 to ensure it reaches the collector tier. See {@link TraceContext#debug()}.

 <p>See <a href="https://github.com/openzipkin/b3-propagation">B3 Propagation</a>]]>
    </doc>
  </class>
  <!-- end class brave.propagation.B3SingleFormat -->
  <!-- start class brave.propagation.B3SinglePropagation -->
  <class name="B3SinglePropagation" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="Since 5.9, use {@link B3Propagation#newFactoryBuilder()} to control inject formats.">
    <constructor name="B3SinglePropagation"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <field name="FACTORY" type="brave.propagation.Propagation.Factory"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Implements the propagation format described in {@link B3SingleFormat}.

 @deprecated Since 5.9, use {@link B3Propagation#newFactoryBuilder()} to control inject formats.]]>
    </doc>
  </class>
  <!-- end class brave.propagation.B3SinglePropagation -->
  <!-- start class brave.propagation.CurrentTraceContext -->
  <class name="CurrentTraceContext" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="CurrentTraceContext"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <constructor name="CurrentTraceContext" type="brave.propagation.CurrentTraceContext.Builder"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="get" return="brave.propagation.TraceContext"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the current span in scope or null if there isn't one.]]>
      </doc>
    </method>
    <method name="newScope" return="brave.propagation.CurrentTraceContext.Scope"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="context" type="brave.propagation.TraceContext"/>
      <doc>
      <![CDATA[Sets the current span in scope until the returned object is closed. It is a programming error
 to drop or never close the result. Using try-with-resources is preferred for this reason.

 @param context span to place into scope or null to clear the scope]]>
      </doc>
    </method>
    <method name="decorateScope" return="brave.propagation.CurrentTraceContext.Scope"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="context" type="brave.propagation.TraceContext"/>
      <param name="scope" type="brave.propagation.CurrentTraceContext.Scope"/>
      <doc>
      <![CDATA[When implementing {@linkplain #newScope(TraceContext)}, decorate the result before returning
 it.

 <p>Ex.
 <pre>{@code
   @Override public Scope newScope(@Nullable TraceContext currentSpan) {
     final TraceContext previous = local.get();
     local.set(currentSpan);
     class ThreadLocalScope implements Scope {
       @Override public void close() {
         local.set(previous);
       }
     }
     Scope result = new ThreadLocalScope();
     // ensure scope hooks are attached to the result
     return decorateScope(currentSpan, result);
   }
 }</pre>

 @param scope {@link Scope#NOOP} if the prior context was equal to the {@code context}
 parameter.]]>
      </doc>
    </method>
    <method name="maybeScope" return="brave.propagation.CurrentTraceContext.Scope"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="context" type="brave.propagation.TraceContext"/>
      <doc>
      <![CDATA[Like {@link #newScope(TraceContext)}, except returns {@link Scope#NOOP} if the given context is
 already in scope. This can reduce overhead when scoping callbacks. However, this will not apply
 any changes, notably in {@link TraceContext#extra()}. As such, it should be used carefully and
 only in conditions where redundancy is possible and the intent is primarily to facilitate
 {@link Tracer#currentSpan}. Most often, this is used to eliminate redundant scopes by
 wrappers.

 <p>For example, RxJava includes hooks to wrap types that represent an asynchronous functional
 composition. For example, {@code flowable.parallel().flatMap(Y).sequential()} Assembly hooks
 can ensure each stage of this operation can see the initial trace context. However, other tools
 can also instrument the stages, including vert.x or even agent instrumentation. When wrapping
 callbacks, it can reduce overhead to use {@code maybeScope} as opposed to {@code newScope}.

 <p>Generally speaking, this is best used for wrappers, such as executor services or lifecycle
 hooks, which usually have no current trace context when invoked.

 <h3>Implementors note</h3>
 <p>For those overriding this method, you must compare {@link TraceContext#traceIdHigh()},
 {@link TraceContext#traceId()} and {@link TraceContext#spanId()} to decide if the contexts are
 equivalent. Due to details of propagation, other data like parent ID are not considered in
 equivalence checks.

 @param context span to place into scope or null to clear the scope
 @return a new scope object or {@link Scope#NOOP} if the input is already the case]]>
      </doc>
    </method>
    <method name="wrap" return="java.util.concurrent.Callable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="task" type="java.util.concurrent.Callable"/>
      <doc>
      <![CDATA[Wraps the input so that it executes with the same context as now.]]>
      </doc>
    </method>
    <method name="wrap" return="java.lang.Runnable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="task" type="java.lang.Runnable"/>
      <doc>
      <![CDATA[Wraps the input so that it executes with the same context as now.]]>
      </doc>
    </method>
    <method name="executor" return="java.util.concurrent.Executor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delegate" type="java.util.concurrent.Executor"/>
      <doc>
      <![CDATA[Decorates the input such that the {@link #get() current trace context} at the time a task is
 scheduled is made current when the task is executed.]]>
      </doc>
    </method>
    <method name="executorService" return="java.util.concurrent.ExecutorService"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delegate" type="java.util.concurrent.ExecutorService"/>
      <doc>
      <![CDATA[Decorates the input such that the {@link #get() current trace context} at the time a task is
 scheduled is made current when the task is executed.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[This makes a given span the current span by placing it in scope (usually but not always a thread
 local scope).

 <p>This type is an SPI, and intended to be used by implementors looking to change thread-local
 storage, or integrate with other contexts such as logging (MDC).

 <h3>Design</h3>

 This design was inspired by com.google.instrumentation.trace.ContextUtils,
 com.google.inject.servlet.RequestScoper and com.github.kristofa.brave.CurrentSpan]]>
    </doc>
  </class>
  <!-- end class brave.propagation.CurrentTraceContext -->
  <!-- start class brave.propagation.CurrentTraceContext.Builder -->
  <class name="CurrentTraceContext.Builder" extends="java.lang.Object"
    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Builder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="addScopeDecorator" return="brave.propagation.CurrentTraceContext.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="scopeDecorator" type="brave.propagation.CurrentTraceContext.ScopeDecorator"/>
      <doc>
      <![CDATA[Implementations call decorators in order to add features like log correlation to a scope.

 @since 5.2]]>
      </doc>
    </method>
    <method name="build" return="brave.propagation.CurrentTraceContext"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Implementations of this allow standardized configuration, for example scope decoration.]]>
    </doc>
  </class>
  <!-- end class brave.propagation.CurrentTraceContext.Builder -->
  <!-- start class brave.propagation.CurrentTraceContext.Default -->
  <class name="CurrentTraceContext.Default" extends="brave.propagation.ThreadLocalCurrentTraceContext"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="create" return="brave.propagation.CurrentTraceContext"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Uses a non-inheritable static thread local]]>
      </doc>
    </method>
    <method name="inheritable" return="brave.propagation.CurrentTraceContext"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Uses an inheritable static thread local which allows arbitrary calls to {@link
 Thread#start()} to automatically inherit this context. This feature is available as it is was
 the default in Brave 3, because some users couldn't control threads in their applications.

 <p>This can be a problem in scenarios such as thread pool expansion, leading to data being
 recorded in the wrong span, or spans with the wrong parent. If you are impacted by this,
 switch to {@link #create()}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Default implementation which is backed by a static thread local.

 <p>A static thread local ensures we have one context per thread, as opposed to one per thread-
 tracer. This means all tracer instances will be able to see any tracer's contexts.

 <p>The trade-off of this (instance-based reference) vs the reverse: trace contexts are not
 separated by tracer by default. For example, to make a trace invisible to another tracer, you
 have to use a non-default implementation.

 <p>Sometimes people make different instances of the tracer just to change configuration like
 the local service name. If we used a thread-instance approach, none of these would be able to
 see eachother's scopes. This would break {@link Tracing#currentTracer()} scope visibility in a
 way few would want to debug. It might be phrased as "MySQL always starts a new trace and I
 don't know why."

 <p>If you want a different behavior, use a different subtype of {@link CurrentTraceContext},
 possibly your own, or raise an issue and explain what your use case is.]]>
    </doc>
  </class>
  <!-- end class brave.propagation.CurrentTraceContext.Default -->
  <!-- start interface brave.propagation.CurrentTraceContext.Scope -->
  <interface name="CurrentTraceContext.Scope"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Closeable"/>
    <method name="close"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[No exceptions are thrown when unbinding a span scope.]]>
      </doc>
    </method>
    <field name="NOOP" type="brave.propagation.CurrentTraceContext.Scope"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returned when {@link CurrentTraceContext#maybeScope(TraceContext)} detected scope
 redundancy.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[A span remains in the scope it was bound to until close is called.]]>
    </doc>
  </interface>
  <!-- end interface brave.propagation.CurrentTraceContext.Scope -->
  <!-- start interface brave.propagation.CurrentTraceContext.ScopeDecorator -->
  <interface name="CurrentTraceContext.ScopeDecorator"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="decorateScope" return="brave.propagation.CurrentTraceContext.Scope"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="context" type="brave.propagation.TraceContext"/>
      <param name="scope" type="brave.propagation.CurrentTraceContext.Scope"/>
      <doc>
      <![CDATA[@param context null implies the scope should be cleared
 @param scope {@link Scope#NOOP} if the former decoration resulted in no change.]]>
      </doc>
    </method>
    <field name="NOOP" type="brave.propagation.CurrentTraceContext.ScopeDecorator"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Use this when configuration results in no decoration needed.

 @since 5.11]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Use this to add features such as thread checks or log correlation when a scope is created or
 closed.

 <p>While decoration technically occurs with {@link #newScope(TraceContext)} or
 {@link #maybeScope(TraceContext)}, many tools use these underneath. For example, {@link
 brave.Tracer#startScopedSpan(String)} and {@link brave.Tracer#withSpanInScope(brave.Span)} set
 a span in scope. An executor wrapped with {@link #executor(Executor)} would decorate each
 runnable.

 @since 5.2]]>
    </doc>
  </interface>
  <!-- end interface brave.propagation.CurrentTraceContext.ScopeDecorator -->
  <!-- start interface brave.propagation.CurrentTraceContextCustomizer -->
  <interface name="CurrentTraceContextCustomizer"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="customize"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="builder" type="brave.propagation.CurrentTraceContext.Builder"/>
    </method>
    <field name="NOOP" type="brave.propagation.CurrentTraceContextCustomizer"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Use to avoid comparing against null references]]>
      </doc>
    </field>
    <doc>
    <![CDATA[This allows configuration plugins to collaborate on building an instance of {@link
 CurrentTraceContext}.

 <p>For example, a customizer can {@link CurrentTraceContext.Builder#addScopeDecorator(CurrentTraceContext.ScopeDecorator)
 add a scope decorator} without affecting the the implementation (like thread locals).

 <p>This also allows one object to customize both {@link BaggagePropagation}, via {@link
 BaggagePropagationCustomizer}, and integration like MDC (log) correlation, by implementing both
 customizer interfaces.

 <h3>Integration examples</h3>

 <p>In practice, a dependency injection tool applies a collection of these instances prior to
 {@link CurrentTraceContext.Builder#build() building the tracing instance}. For example, an
 injected {@code List<CurrentTraceContextCustomizer>} parameter to a provider of {@link
 CurrentTraceContext}.

 <p>Here are some examples, in alphabetical order:
 <pre><ul>
   <li><a href="https://dagger.dev/multibindings.html">Dagger Set Multibindings</a></li>
   <li><a href="http://google.github.io/guice/api-docs/latest/javadoc/com/google/inject/multibindings/Multibinder.html">Guice Set Multibinder</a></li>
   <li><a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-autowired-annotation">Spring Autowired Collections</a></li>
 </ul></pre>

 @see BaggagePropagationCustomizer
 @see TracingCustomizer
 @since 5.7]]>
    </doc>
  </interface>
  <!-- end interface brave.propagation.CurrentTraceContextCustomizer -->
  <!-- start interface brave.propagation.ExtraFieldCustomizer -->
  <interface name="ExtraFieldCustomizer"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="Since 5.11 use {@link BaggagePropagationCustomizer}">
    <method name="customize"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="builder" type="brave.propagation.ExtraFieldPropagation.FactoryBuilder"/>
    </method>
    <field name="NOOP" type="brave.propagation.ExtraFieldCustomizer"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Use to avoid comparing against null references]]>
      </doc>
    </field>
    <doc>
    <![CDATA[@since 5.7
 @deprecated Since 5.11 use {@link BaggagePropagationCustomizer}]]>
    </doc>
  </interface>
  <!-- end interface brave.propagation.ExtraFieldCustomizer -->
  <!-- start class brave.propagation.ExtraFieldPropagation -->
  <class name="ExtraFieldPropagation" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="Since 5.11 use {@link BaggagePropagation}">
    <implements name="brave.propagation.Propagation"/>
    <method name="newFactory" return="brave.propagation.ExtraFieldPropagation.Factory"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Since 5.11 use {@link BaggagePropagation#newFactoryBuilder(Propagation.Factory)}">
      <param name="delegate" type="brave.propagation.Propagation.Factory"/>
      <param name="names" type="java.lang.String[]"/>
      <doc>
      <![CDATA[@deprecated Since 5.11 use {@link BaggagePropagation#newFactoryBuilder(Propagation.Factory)}]]>
      </doc>
    </method>
    <method name="newFactory" return="brave.propagation.ExtraFieldPropagation.Factory"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Since 5.11 use {@link BaggagePropagation#newFactoryBuilder(Propagation.Factory)}">
      <param name="delegate" type="brave.propagation.Propagation.Factory"/>
      <param name="names" type="java.util.Collection"/>
      <doc>
      <![CDATA[@deprecated Since 5.11 use {@link BaggagePropagation#newFactoryBuilder(Propagation.Factory)}]]>
      </doc>
    </method>
    <method name="newFactoryBuilder" return="brave.propagation.ExtraFieldPropagation.FactoryBuilder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Since 5.11 use {@link BaggagePropagation#newFactoryBuilder(Propagation.Factory)}">
      <param name="delegate" type="brave.propagation.Propagation.Factory"/>
      <doc>
      <![CDATA[@deprecated Since 5.11 use {@link BaggagePropagation#newFactoryBuilder(Propagation.Factory)}]]>
      </doc>
    </method>
    <method name="current" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Since 5.11 use {@link BaggageField#getByName(String)} and {@link
 BaggageField#getValue()}">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[@deprecated Since 5.11 use {@link BaggageField#getByName(String)} and {@link
 BaggageField#getValue()}]]>
      </doc>
    </method>
    <method name="get" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Since 5.11 use {@link BaggageField#getByName(String)} and {@link
 BaggageField#getValue()}">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[@deprecated Since 5.11 use {@link BaggageField#getByName(String)} and {@link
 BaggageField#getValue()}]]>
      </doc>
    </method>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Since 5.11 use {@link BaggageField#getByName(String)} and {@link
 BaggageField#updateValue(String)}">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[@deprecated Since 5.11 use {@link BaggageField#getByName(String)} and {@link
 BaggageField#updateValue(String)}]]>
      </doc>
    </method>
    <method name="getAll" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Since 5.11 use {@link BaggageField#getAll()}">
      <doc>
      <![CDATA[@deprecated Since 5.11 use {@link BaggageField#getAll()}]]>
      </doc>
    </method>
    <method name="getAll" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Since 5.11 use {@link BaggageField#getAll(TraceContextOrSamplingFlags)}">
      <param name="extracted" type="brave.propagation.TraceContextOrSamplingFlags"/>
      <doc>
      <![CDATA[@deprecated Since 5.11 use {@link BaggageField#getAll(TraceContextOrSamplingFlags)}]]>
      </doc>
    </method>
    <method name="getAll" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Since 5.11 use {@link BaggageField#getAll(TraceContext)}">
      <param name="context" type="brave.propagation.TraceContext"/>
      <doc>
      <![CDATA[@deprecated Since 5.11 use {@link BaggageField#getAll(TraceContext)}]]>
      </doc>
    </method>
    <method name="get" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Since 5.11 use {@link BaggageField#getByName(TraceContext, String)} and {@link
 BaggageField#getValue(TraceContext)}">
      <param name="context" type="brave.propagation.TraceContext"/>
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[@deprecated Since 5.11 use {@link BaggageField#getByName(TraceContext, String)} and {@link
 BaggageField#getValue(TraceContext)}]]>
      </doc>
    </method>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Since 5.11 use {@link BaggageField#getByName(TraceContext, String)} and {@link
 BaggageField#updateValue(String)}">
      <param name="context" type="brave.propagation.TraceContext"/>
      <param name="name" type="java.lang.String"/>
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[@deprecated Since 5.11 use {@link BaggageField#getByName(TraceContext, String)} and {@link
 BaggageField#updateValue(String)}]]>
      </doc>
    </method>
    <method name="extraKeys" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Since 5.11 do not use this, as it was only added for OpenTracing. brave-opentracing
 works around this.">
      <doc>
      <![CDATA[Returns the extra keys this component can extract. This result is lowercase and does not
 include any {@link #keys() trace context keys}.

 @deprecated Since 5.11 do not use this, as it was only added for OpenTracing. brave-opentracing
 works around this.]]>
      </doc>
    </method>
    <method name="keys" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Only returns trace context keys. Extra field names are not returned to ensure tools don't
 delete them. This is to support users accessing extra fields without Brave apis (ex via
 headers).]]>
      </doc>
    </method>
    <method name="injector" return="brave.propagation.TraceContext.Injector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="setter" type="brave.propagation.Propagation.Setter"/>
    </method>
    <method name="extractor" return="brave.propagation.TraceContext.Extractor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="getter" type="brave.propagation.Propagation.Getter"/>
    </method>
    <doc>
    <![CDATA[@deprecated Since 5.11 use {@link BaggagePropagation}]]>
    </doc>
  </class>
  <!-- end class brave.propagation.ExtraFieldPropagation -->
  <!-- start class brave.propagation.ExtraFieldPropagation.Factory -->
  <class name="ExtraFieldPropagation.Factory" extends="brave.propagation.Propagation.Factory"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="Since 5.11 use {@link Propagation.Factory}">
    <method name="create" return="brave.propagation.ExtraFieldPropagation"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keyFactory" type="brave.propagation.Propagation.KeyFactory"/>
    </method>
    <method name="supportsJoin" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="requires128BitTraceId" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="decorate" return="brave.propagation.TraceContext"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="context" type="brave.propagation.TraceContext"/>
    </method>
    <doc>
    <![CDATA[@deprecated Since 5.11 use {@link Propagation.Factory}]]>
    </doc>
  </class>
  <!-- end class brave.propagation.ExtraFieldPropagation.Factory -->
  <!-- start class brave.propagation.ExtraFieldPropagation.FactoryBuilder -->
  <class name="ExtraFieldPropagation.FactoryBuilder" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="Since 5.11 use {@link BaggagePropagation.FactoryBuilder}">
    <method name="addRedactedField" return="brave.propagation.ExtraFieldPropagation.FactoryBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Since 5.11, use {@link SingleBaggageField#local(BaggageField)}">
      <param name="fieldName" type="java.lang.String"/>
      <doc>
      <![CDATA[@deprecated Since 5.11, use {@link SingleBaggageField#local(BaggageField)}]]>
      </doc>
    </method>
    <method name="addField" return="brave.propagation.ExtraFieldPropagation.FactoryBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Since 5.11, use {@link SingleBaggageField#remote(BaggageField)}">
      <param name="fieldName" type="java.lang.String"/>
      <doc>
      <![CDATA[@deprecated Since 5.11, use {@link SingleBaggageField#remote(BaggageField)}]]>
      </doc>
    </method>
    <method name="addPrefixedFields" return="brave.propagation.ExtraFieldPropagation.FactoryBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Since 5.11, use {@link SingleBaggageField.Builder#addKeyName(String)}">
      <param name="prefix" type="java.lang.String"/>
      <param name="names" type="java.util.Collection"/>
      <doc>
      <![CDATA[@deprecated Since 5.11, use {@link SingleBaggageField.Builder#addKeyName(String)}]]>
      </doc>
    </method>
    <method name="build" return="brave.propagation.ExtraFieldPropagation.Factory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a wrapper of the delegate if there are no fields to propagate.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[@deprecated Since 5.11 use {@link BaggagePropagation.FactoryBuilder}]]>
    </doc>
  </class>
  <!-- end class brave.propagation.ExtraFieldPropagation.FactoryBuilder -->
  <!-- start interface brave.propagation.Propagation -->
  <interface name="Propagation"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="keys" return="java.util.List"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The propagation fields defined. If your carrier is reused, you should delete the fields here
 before calling {@link Setter#put(Object, Object, String)}.

 <p>For example, if the carrier is a single-use or immutable request object, you don't need to
 clear fields as they couldn't have been set before. If it is a mutable, retryable object,
 successive calls should clear these fields first.

 <p><em>Note:</em> Depending on the format, keys returned may not all be mandatory.

 <p><em>Note:</em> If your implementation carries baggage, such as correlation IDs, do not
 return the names of those fields here. If you do, they will be deleted, which can interfere
 with user headers.]]>
      </doc>
    </method>
    <method name="injector" return="brave.propagation.TraceContext.Injector"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="setter" type="brave.propagation.Propagation.Setter"/>
      <doc>
      <![CDATA[Replaces a propagated field with the given value. Saved as a constant to avoid runtime
 allocations.

 For example, a setter for an {@link java.net.HttpURLConnection} would be the method reference
 {@link java.net.HttpURLConnection#addRequestProperty(String, String)}

 @param setter invoked for each propagation key to add.]]>
      </doc>
    </method>
    <method name="extractor" return="brave.propagation.TraceContext.Extractor"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="getter" type="brave.propagation.Propagation.Getter"/>
      <doc>
      <![CDATA[@param getter invoked for each propagation key to get.]]>
      </doc>
    </method>
    <field name="B3_STRING" type="brave.propagation.Propagation"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="B3_SINGLE_STRING" type="brave.propagation.Propagation"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="Since 5.9, use {@link B3Propagation#newFactoryBuilder()} to control inject formats.">
      <doc>
      <![CDATA[@deprecated Since 5.9, use {@link B3Propagation#newFactoryBuilder()} to control inject formats.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Injects and extracts {@link TraceContext trace identifiers} as text into carriers that travel
 in-band across process boundaries. Identifiers are often encoded as messaging or RPC request
 headers.

 <h3>Propagation example: Http</h3>

 <p>When using http, the carrier of propagated data on both the client (injector) and server
 (extractor) side is usually an http request. Propagation is usually implemented via library-
 specific request interceptors, where the client-side injects span identifiers and the server-side
 extracts them.

 @param <K> Usually, but not always a String]]>
    </doc>
  </interface>
  <!-- end interface brave.propagation.Propagation -->
  <!-- start class brave.propagation.Propagation.Factory -->
  <class name="Propagation.Factory" extends="java.lang.Object"
    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Factory"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="supportsJoin" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Does the propagation implementation support sharing client and server span IDs. For example,
 should an RPC server span share the same identifiers extracted from an incoming request?

 In usual <a href="https://github.com/openzipkin/b3-propagation">B3 Propagation</a>, the
 parent span ID is sent across the wire so that the client and server can share the same
 identifiers. Other propagation formats, like <a href="https://github.com/w3c/trace-context">trace-context</a>
 only propagate the calling trace and span ID, with an assumption that the receiver always
 starts a new child span. When join is supported, you can assume that when {@link
 TraceContext#parentId() the parent span ID} is null, you've been propagated a root span. When
 join is not supported, you must always fork a new child.]]>
      </doc>
    </method>
    <method name="requires128BitTraceId" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="create" return="brave.propagation.Propagation"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keyFactory" type="brave.propagation.Propagation.KeyFactory"/>
    </method>
    <method name="decorate" return="brave.propagation.TraceContext"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="context" type="brave.propagation.TraceContext"/>
      <doc>
      <![CDATA[Decorates the input such that it can propagate extra state, such as a timestamp or baggage.

 <p>Implementations are responsible for data scoping, if relevant. For example, if only
 global configuration is present, it could suffice to simply ensure that data is present. If
 data is span-scoped, an implementation might compare the context to its last span ID, copying
 on write or otherwise to ensure writes to one context don't affect another.

 <p>Implementations should be idempotent, returning the same instance instead of re-applying
 change.

 @see TraceContext#extra()]]>
      </doc>
    </method>
  </class>
  <!-- end class brave.propagation.Propagation.Factory -->
  <!-- start interface brave.propagation.Propagation.Getter -->
  <interface name="Propagation.Getter"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="get" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="carrier" type="java.lang.Object"/>
      <param name="key" type="java.lang.Object"/>
    </method>
    <doc>
    <![CDATA[Gets the first value of the given propagation key or returns null]]>
    </doc>
  </interface>
  <!-- end interface brave.propagation.Propagation.Getter -->
  <!-- start interface brave.propagation.Propagation.KeyFactory -->
  <interface name="Propagation.KeyFactory"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="create" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <field name="STRING" type="brave.propagation.Propagation.KeyFactory"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Creates keys for use in propagated contexts]]>
    </doc>
  </interface>
  <!-- end interface brave.propagation.Propagation.KeyFactory -->
  <!-- start interface brave.propagation.Propagation.Setter -->
  <interface name="Propagation.Setter"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="put"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="carrier" type="java.lang.Object"/>
      <param name="key" type="java.lang.Object"/>
      <param name="value" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[Replaces a propagated key with the given value]]>
    </doc>
  </interface>
  <!-- end interface brave.propagation.Propagation.Setter -->
  <!-- start class brave.propagation.SamplingFlags -->
  <class name="SamplingFlags" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="sampled" return="java.lang.Boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Sampled means send span data to Zipkin (or something else compatible with its data). It is a
 consistent decision for an entire request (trace-scoped). For example, the value should not
 move from true to false, even if the decision itself can be deferred.

 <p>Here are the valid options:
 <pre><ul>
   <li>True means the trace is reported, starting with the first span to set the value true</li>
   <li>False means the trace should not be reported</li>
   <li>Null means the decision should be deferred to the next hop</li>
 </ul></pre>

 <p>Once set to true or false, it is expected that this decision is propagated and honored
 downstream.

 <p>Note: sampling does not imply the trace is invisible to others. For example, a common
 practice is to generate and propagate identifiers always. This allows other systems, such as
 logging, to correlate even when the tracing system has no data.]]>
      </doc>
    </method>
    <method name="sampledLocal" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[True records this trace locally even if it is not {@link #sampled() sampled downstream}.
 Defaults to false.

 <p><em>Note:</em> Setting this does not affect {@link #sampled() remote sampled status}.

 <p>The use case for this is storing data at other sampling rates, or local aggregation of
 metrics or service aggregations. How to action this data may or may not require inspection of
 {@link TraceContext#extra() other propagated information}.]]>
      </doc>
    </method>
    <method name="debug" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[True implies {@link #sampled()}, and is additionally a request to override any storage or
 collector layer sampling. Defaults to false.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="EMPTY" type="brave.propagation.SamplingFlags"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="NOT_SAMPLED" type="brave.propagation.SamplingFlags"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="SAMPLED" type="brave.propagation.SamplingFlags"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="DEBUG" type="brave.propagation.SamplingFlags"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class brave.propagation.SamplingFlags -->
  <!-- start class brave.propagation.SamplingFlags.Builder -->
  <class name="SamplingFlags.Builder" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="prefer using constants. This will be removed in Brave v6">
    <constructor name="Builder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="sampled" return="brave.propagation.SamplingFlags.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sampled" type="java.lang.Boolean"/>
      <doc>
      <![CDATA[@see SamplingFlags#sampled()]]>
      </doc>
    </method>
    <method name="debug" return="brave.propagation.SamplingFlags.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="debug" type="boolean"/>
      <doc>
      <![CDATA[Setting debug to true also sets sampled to true.

 @see SamplingFlags#debug()]]>
      </doc>
    </method>
    <method name="build" return="brave.propagation.SamplingFlags"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sampled" type="java.lang.Boolean"/>
      <doc>
      <![CDATA[Allows you to create flags from a boolean value without allocating a builder instance]]>
      </doc>
    </method>
    <method name="build" return="brave.propagation.SamplingFlags"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@deprecated prefer using constants. This will be removed in Brave v6]]>
    </doc>
  </class>
  <!-- end class brave.propagation.SamplingFlags.Builder -->
  <!-- start class brave.propagation.StrictCurrentTraceContext -->
  <class name="StrictCurrentTraceContext" extends="brave.propagation.CurrentTraceContext"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Closeable"/>
    <constructor name="StrictCurrentTraceContext"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="create" return="brave.propagation.StrictCurrentTraceContext"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@since 5.11]]>
      </doc>
    </method>
    <method name="newBuilder" return="brave.propagation.StrictCurrentTraceContext.Builder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@since 5.11]]>
      </doc>
    </method>
    <method name="get" return="brave.propagation.TraceContext"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="newScope" return="brave.propagation.CurrentTraceContext.Scope"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="context" type="brave.propagation.TraceContext"/>
    </method>
    <method name="maybeScope" return="brave.propagation.CurrentTraceContext.Scope"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="context" type="brave.propagation.TraceContext"/>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Calls {@link StrictScopeDecorator#close()}

 @since 5.11]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Useful when developing instrumentation as state is enforced more strictly.

 <p>For example, it is instance scoped as opposed to static scoped, not inheritable and throws an
 exception if a scope is closed on a different thread that it was opened on.

 @see StrictScopeDecorator]]>
    </doc>
  </class>
  <!-- end class brave.propagation.StrictCurrentTraceContext -->
  <!-- start class brave.propagation.StrictCurrentTraceContext.Builder -->
  <class name="StrictCurrentTraceContext.Builder" extends="brave.propagation.CurrentTraceContext.Builder"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="build" return="brave.propagation.StrictCurrentTraceContext"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="addScopeDecorator" return="brave.propagation.StrictCurrentTraceContext.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="scopeDecorator" type="brave.propagation.CurrentTraceContext.ScopeDecorator"/>
    </method>
  </class>
  <!-- end class brave.propagation.StrictCurrentTraceContext.Builder -->
  <!-- start class brave.propagation.StrictScopeDecorator -->
  <class name="StrictScopeDecorator" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="brave.propagation.CurrentTraceContext.ScopeDecorator"/>
    <implements name="java.io.Closeable"/>
    <method name="create" return="brave.propagation.StrictScopeDecorator"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="decorateScope" return="brave.propagation.CurrentTraceContext.Scope"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="context" type="brave.propagation.TraceContext"/>
      <param name="scope" type="brave.propagation.CurrentTraceContext.Scope"/>
      <doc>
      <![CDATA[Identifies problems by throwing {@link IllegalStateException} when a scope is closed on a
 different thread.]]>
      </doc>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[This is useful in tests to help ensure scopes are not leaked by instrumentation.

 <p><em>Note:</em> It is important to close all resources prior to calling this, so that
 in-flight operations are not mistaken as scope leaks. If this raises an error, consider if a
 {@linkplain CurrentTraceContext#executor(Executor) wrapped executor} is still running.

 @throws AssertionError if any scopes were left unclosed.
 @since 5.11]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Useful when developing instrumentation as state is enforced more strictly.

 <p>Ex.
 <pre>{@code
 tracing = Tracing.newBuilder()
                  .spanReporter(...)
                  .currentTraceContext(ThreadLocalCurrentTraceContext.newBuilder()
                    .addScopeDecorator(StrictScopeDecorator.create())
                    .build()
                  ).build();
 }</pre>]]>
    </doc>
  </class>
  <!-- end class brave.propagation.StrictScopeDecorator -->
  <!-- start class brave.propagation.ThreadLocalCurrentTraceContext -->
  <class name="ThreadLocalCurrentTraceContext" extends="brave.propagation.CurrentTraceContext"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="create" return="brave.propagation.CurrentTraceContext"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="newBuilder" return="brave.propagation.ThreadLocalCurrentTraceContext.Builder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="clear"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[This component is backed by a possibly static shared thread local. Call this to clear the
 reference when you are sure any residual state is due to a leak. This is generally only useful
 in tests.

 @since 5.11]]>
      </doc>
    </method>
    <method name="get" return="brave.propagation.TraceContext"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="newScope" return="brave.propagation.CurrentTraceContext.Scope"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="currentSpan" type="brave.propagation.TraceContext"/>
    </method>
    <doc>
    <![CDATA[In-process trace context propagation backed by a static thread local.

 <h3>Design notes</h3>

 <p>A static thread local ensures we have one context per thread, as opposed to one per thread-
 tracer. This means all tracer instances will be able to see any tracer's contexts.

 <p>The trade-off of this (instance-based reference) vs the reverse: trace contexts are not
 separated by tracer by default. For example, to make a trace invisible to another tracer, you
 have to use a non-default implementation.

 <p>Sometimes people make different instances of the tracer just to change configuration like
 the local service name. If we used a thread-instance approach, none of these would be able to see
 eachother's scopes. This would break {@link Tracing#currentTracer()} scope visibility in a way
 few would want to debug. It might be phrased as "MySQL always starts a new trace and I don't know
 why."

 <p>If you want a different behavior, use a different subtype of {@link CurrentTraceContext},
 possibly your own, or raise an issue and explain what your use case is.]]>
    </doc>
  </class>
  <!-- end class brave.propagation.ThreadLocalCurrentTraceContext -->
  <!-- start class brave.propagation.ThreadLocalCurrentTraceContext.Builder -->
  <class name="ThreadLocalCurrentTraceContext.Builder" extends="brave.propagation.CurrentTraceContext.Builder"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="addScopeDecorator" return="brave.propagation.ThreadLocalCurrentTraceContext.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="scopeDecorator" type="brave.propagation.CurrentTraceContext.ScopeDecorator"/>
    </method>
    <method name="build" return="brave.propagation.ThreadLocalCurrentTraceContext"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@since 5.11]]>
    </doc>
  </class>
  <!-- end class brave.propagation.ThreadLocalCurrentTraceContext.Builder -->
  <!-- start class brave.propagation.ThreadLocalSpan -->
  <class name="ThreadLocalSpan" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="create" return="brave.propagation.ThreadLocalSpan"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tracer" type="brave.Tracer"/>
    </method>
    <method name="next" return="brave.Span"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="extracted" type="brave.propagation.TraceContextOrSamplingFlags"/>
      <doc>
      <![CDATA[Returns the {@link Tracer#nextSpan(TraceContextOrSamplingFlags)} or null if {@link
 #CURRENT_TRACER} and tracing isn't available.]]>
      </doc>
    </method>
    <method name="next" return="brave.Span"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the {@link Tracer#nextSpan()} or null if {@link #CURRENT_TRACER} and tracing isn't
 available.]]>
      </doc>
    </method>
    <method name="remove" return="brave.Span"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the span set in scope via {@link #next()} or null if there was none.

 <p>When assertions are on, this will throw an assertion error if the span returned was not the
 one currently in context. This could happen if someone called {@link
 Tracer#withSpanInScope(Span)} or {@link CurrentTraceContext#newScope(TraceContext)} outside a
 try/finally block.]]>
      </doc>
    </method>
    <field name="CURRENT_TRACER" type="brave.propagation.ThreadLocalSpan"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[This uses the {@link Tracing#currentTracer()}, which means calls to {@link #next()} may return
 null. Use this when you have no other means to get a reference to the tracer. For example, JDBC
 connections, as they often initialize prior to the tracing component.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[This type allows you to place a span in scope in one method and access it in another without
 using an explicit request parameter.

 <p>Many libraries expose a callback model as opposed to an interceptor one. When creating new
 instrumentation, you may find places where you need to place a span in scope in one callback
 (like `onStart()`) and end the scope in another callback (like `onFinish()`).

 <p>Provided the library guarantees these run on the same thread, you can simply propagate the
 result of {@link Tracer#startScopedSpan(String)} or {@link Tracer#withSpanInScope(Span)} from the
 starting callback to the closing one. This is typically done with a request-scoped attribute.

 Here's an example:
 <pre>{@code
 class MyFilter extends Filter {
   public void onStart(Request request, Attributes attributes) {
     // Assume you have code to start the span and add relevant tags...

     // We now set the span in scope so that any code between here and
     // the end of the request can see it with Tracer.currentSpan()
     SpanInScope spanInScope = tracer.withSpanInScope(span);

     // We don't want to leak the scope, so we place it somewhere we can
     // lookup later
     attributes.put(SpanInScope.class, spanInScope);
   }

   public void onFinish(Response response, Attributes attributes) {
     // as long as we are on the same thread, we can read the span started above
     Span span = tracer.currentSpan();

     // Assume you have code to complete the span

     // We now remove the scope (which implicitly detaches it from the span)
     attributes.remove(SpanInScope.class).close();
   }
 }
 }</pre>

 <p>Sometimes you have to instrument a library where There's no attribute namespace shared across
 request and response. For this scenario, you can use {@link ThreadLocalSpan} to temporarily store
 the span between callbacks.

 Here's an example:
 <pre>{@code
 class MyFilter extends Filter {
   final ThreadLocalSpan threadLocalSpan;

   public void onStart(Request request) {
     // Allocates a span and places it in scope so that code between here and onFinish can see it
     Span span = threadLocalSpan.next();
     if (span == null || span.isNoop()) return; // skip below logic on noop

     // Assume you have code to start the span and add relevant tags...
   }

   public void onFinish(Response response, Attributes attributes) {
     // as long as we are on the same thread, we can read the span started above
     Span span = threadLocalSpan.remove();
     if (span == null || span.isNoop()) return; // skip below logic on noop

     // Assume you have code to complete the span
   }
 }
 }</pre>]]>
    </doc>
  </class>
  <!-- end class brave.propagation.ThreadLocalSpan -->
  <!-- start class brave.propagation.TraceContext -->
  <class name="TraceContext" extends="brave.propagation.SamplingFlags"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="newBuilder" return="brave.propagation.TraceContext.Builder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="traceIdHigh" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[When non-zero, the trace containing this span uses 128-bit trace identifiers.]]>
      </doc>
    </method>
    <method name="traceId" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Unique 8-byte identifier for a trace, set on all spans within it.]]>
      </doc>
    </method>
    <method name="localRootId" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the first {@link #spanId()} in a partition of a trace: otherwise known as an entry
 span. This could be a root span or a span representing incoming work (ex {@link
 Span.Kind#SERVER} or {@link Span.Kind#CONSUMER}. Unlike {@link #parentIdAsLong()}, this value
 is inherited to child contexts until the trace exits the process. This value is inherited for
 all child spans until the trace exits the process. This could also be described as an entry
 span.

 <p>When {@link #isLocalRoot()}, this ID will be the same as the {@link #spanId() span ID}.

 <p>The local root ID can be used for dependency link processing, skipping data or partitioning
 purposes. For example, one processor could skip all intermediate (local) spans between an
 incoming service call and any outgoing ones.

 <p>This does not group together multiple points of entry in the same trace. For example,
 repetitive consumption of the same incoming message results in different local roots.

 @return the {@link #spanId() span ID} of the local root or zero if this context wasn't
 initialized by a {@link brave.Tracer}.]]>
      </doc>
    </method>
    <method name="isLocalRoot" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="parentId" return="java.lang.Long"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The parent's {@link #spanId} or null if this the root span in a trace.

 @see #parentIdAsLong()]]>
      </doc>
    </method>
    <method name="parentIdAsLong" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Like {@link #parentId()} except returns a primitive where zero implies absent.

 <p>Using this method will avoid allocation, so is encouraged when copying data.]]>
      </doc>
    </method>
    <method name="spanId" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Unique 8-byte identifier of this span within a trace.

 <p>A span is uniquely identified in storage by ({@linkplain #traceId}, {@linkplain #spanId}).]]>
      </doc>
    </method>
    <method name="shared" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[True if we are recording a server span with the same span ID parsed from incoming headers.

 <h3>Impact on indexing</h3>
 <p>When an RPC trace is client-originated, it will be sampled and the same span ID is used for
 the server side. The shared flag helps prioritize timestamp and duration indexing in favor of
 the client. In v1 format, there is no shared flag, so it implies converters should not store
 timestamp and duration on the server span explicitly.]]>
      </doc>
    </method>
    <method name="extra" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a list of additional data propagated through this trace.

 <p>The contents are intentionally opaque, deferring to {@linkplain Propagation} to define. An
 example implementation could be storing a class containing a correlation value, which is
 extracted from incoming requests and injected as-is onto outgoing requests.

 <p>Implementations are responsible for scoping any data stored here. This can be performed
 when {@link Propagation.Factory#decorate(TraceContext)} is called.]]>
      </doc>
    </method>
    <method name="findExtra" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class"/>
      <doc>
      <![CDATA[Returns a {@linkplain #extra() propagated state} of the given type if present or null if not.

 <p>Note: It is the responsibility of {@link Propagation.Factory#decorate(TraceContext)}
 to consolidate elements. If it doesn't, there could be multiple instances of a given type and
 this can break logic.]]>
      </doc>
    </method>
    <method name="toBuilder" return="brave.propagation.TraceContext.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="traceIdString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the hex representation of the span's trace ID]]>
      </doc>
    </method>
    <method name="parentIdString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the hex representation of the span's parent ID]]>
      </doc>
    </method>
    <method name="localRootIdString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the hex representation of the span's local root ID]]>
      </doc>
    </method>
    <method name="spanIdString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the hex representation of the span's ID]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns {@code $traceId/$spanId}]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
      <doc>
      <![CDATA[Includes mandatory fields {@link #traceIdHigh()}, {@link #traceId()}, {@link #spanId()} and the
 {@link #shared() shared flag}.

 <p>The shared flag is included to have parity with the {@link #hashCode()}.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Includes mandatory fields {@link #traceIdHigh()}, {@link #traceId()}, {@link #spanId()} and the
 {@link #shared() shared flag}.

 <p>The shared flag is included in the hash code to ensure loopback span data are partitioned
 properly. For example, if a client calls itself, the server-side shouldn't overwrite the client
 side.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Contains trace identifiers and sampling data propagated in and out-of-process.

 <p>Particularly, this includes trace identifiers and sampled state.

 <p>The implementation was originally {@code com.github.kristofa.brave.SpanId}, which was a
 port of {@code com.twitter.finagle.tracing.TraceId}. Unlike these mentioned, this type does not
 expose a single binary representation. That's because propagation forms can now vary.]]>
    </doc>
  </class>
  <!-- end class brave.propagation.TraceContext -->
  <!-- start class brave.propagation.TraceContext.Builder -->
  <class name="TraceContext.Builder" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="traceIdHigh" return="brave.propagation.TraceContext.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="traceIdHigh" type="long"/>
      <doc>
      <![CDATA[@see TraceContext#traceIdHigh()]]>
      </doc>
    </method>
    <method name="traceId" return="brave.propagation.TraceContext.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="traceId" type="long"/>
      <doc>
      <![CDATA[@see TraceContext#traceId()]]>
      </doc>
    </method>
    <method name="parentId" return="brave.propagation.TraceContext.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="parentId" type="long"/>
      <doc>
      <![CDATA[@see TraceContext#parentIdAsLong()]]>
      </doc>
    </method>
    <method name="parentId" return="brave.propagation.TraceContext.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="parentId" type="java.lang.Long"/>
      <doc>
      <![CDATA[@see TraceContext#parentId()]]>
      </doc>
    </method>
    <method name="spanId" return="brave.propagation.TraceContext.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="spanId" type="long"/>
      <doc>
      <![CDATA[@see TraceContext#spanId()]]>
      </doc>
    </method>
    <method name="sampledLocal" return="brave.propagation.TraceContext.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sampledLocal" type="boolean"/>
      <doc>
      <![CDATA[@see TraceContext#sampledLocal()]]>
      </doc>
    </method>
    <method name="sampled" return="brave.propagation.TraceContext.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sampled" type="boolean"/>
      <doc>
      <![CDATA[@see TraceContext#sampled()]]>
      </doc>
    </method>
    <method name="sampled" return="brave.propagation.TraceContext.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sampled" type="java.lang.Boolean"/>
      <doc>
      <![CDATA[@see TraceContext#sampled()]]>
      </doc>
    </method>
    <method name="debug" return="brave.propagation.TraceContext.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="debug" type="boolean"/>
      <doc>
      <![CDATA[@see TraceContext#debug()]]>
      </doc>
    </method>
    <method name="shared" return="brave.propagation.TraceContext.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="shared" type="boolean"/>
      <doc>
      <![CDATA[@see TraceContext#shared()]]>
      </doc>
    </method>
    <method name="extra" return="brave.propagation.TraceContext.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="extra" type="java.util.List"/>
      <doc>
      <![CDATA[Shares the input with the builder, replacing any current data in the builder.

 @see TraceContext#extra()]]>
      </doc>
    </method>
    <method name="build" return="brave.propagation.TraceContext"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@throws IllegalArgumentException if missing trace ID or span ID]]>
      </doc>
    </method>
  </class>
  <!-- end class brave.propagation.TraceContext.Builder -->
  <!-- start interface brave.propagation.TraceContext.Extractor -->
  <interface name="TraceContext.Extractor"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="extract" return="brave.propagation.TraceContextOrSamplingFlags"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="carrier" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns either a trace context or sampling flags parsed from the carrier. If nothing was
 parsable, sampling flags will be set to {@link SamplingFlags#EMPTY}.

 @param carrier holds propagation fields. For example, an incoming message or http request.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Used to continue an incoming trace. For example, by reading http headers.

 @see brave.Tracer#nextSpan(TraceContextOrSamplingFlags)]]>
    </doc>
  </interface>
  <!-- end interface brave.propagation.TraceContext.Extractor -->
  <!-- start interface brave.propagation.TraceContext.Injector -->
  <interface name="TraceContext.Injector"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="inject"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="traceContext" type="brave.propagation.TraceContext"/>
      <param name="carrier" type="java.lang.Object"/>
      <doc>
      <![CDATA[Usually calls a setter for each propagation field to send downstream.

 @param traceContext possibly unsampled.
 @param carrier holds propagation fields. For example, an outgoing message or http request.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Used to send the trace context downstream. For example, as http headers.

 <p>For example, to put the context on an {@link java.net.HttpURLConnection}, you can do this:
 <pre>{@code
 // in your constructor
 injector = tracing.propagation().injector(URLConnection::setRequestProperty);

 // later in your code, reuse the function you created above to add trace headers
 HttpURLConnection connection = (HttpURLConnection) new URL("http://myserver").openConnection();
 injector.inject(span.context(), connection);
 }</pre>]]>
    </doc>
  </interface>
  <!-- end interface brave.propagation.TraceContext.Injector -->
  <!-- start class brave.propagation.TraceContextOrSamplingFlags -->
  <class name="TraceContextOrSamplingFlags" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="newBuilder" return="brave.propagation.TraceContextOrSamplingFlags.Builder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="sampled" return="java.lang.Boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns {@link SamplingFlags#sampled()}, regardless of subtype.]]>
      </doc>
    </method>
    <method name="sampledLocal" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns {@link SamplingFlags#sampledLocal()}}, regardless of subtype.]]>
      </doc>
    </method>
    <method name="sampled" return="brave.propagation.TraceContextOrSamplingFlags"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="do not use object variant.. only set when you have a sampling decision">
      <param name="sampled" type="java.lang.Boolean"/>
      <doc>
      <![CDATA[@deprecated do not use object variant.. only set when you have a sampling decision]]>
      </doc>
    </method>
    <method name="sampled" return="brave.propagation.TraceContextOrSamplingFlags"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sampled" type="boolean"/>
    </method>
    <method name="context" return="brave.propagation.TraceContext"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="traceIdContext" return="brave.propagation.TraceIdContext"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="samplingFlags" return="brave.propagation.SamplingFlags"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="extra" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Non-empty when {@link #context} is null: A list of additional state extracted from the
 carrier.

 @see TraceContext#extra()]]>
      </doc>
    </method>
    <method name="toBuilder" return="brave.propagation.TraceContextOrSamplingFlags.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="create" return="brave.propagation.TraceContextOrSamplingFlags"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="context" type="brave.propagation.TraceContext"/>
    </method>
    <method name="create" return="brave.propagation.TraceContextOrSamplingFlags"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="traceIdContext" type="brave.propagation.TraceIdContext"/>
    </method>
    <method name="create" return="brave.propagation.TraceContextOrSamplingFlags"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="flags" type="brave.propagation.SamplingFlags"/>
    </method>
    <method name="create" return="brave.propagation.TraceContextOrSamplingFlags"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sampled" type="java.lang.Boolean"/>
      <param name="debug" type="boolean"/>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="EMPTY" type="brave.propagation.TraceContextOrSamplingFlags"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="NOT_SAMPLED" type="brave.propagation.TraceContextOrSamplingFlags"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="SAMPLED" type="brave.propagation.TraceContextOrSamplingFlags"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="DEBUG" type="brave.propagation.TraceContextOrSamplingFlags"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Union type that contains only one of trace context, trace ID context or sampling flags. This type
 is designed for use with {@link Tracer#nextSpan(TraceContextOrSamplingFlags)}.

 <p>Users should not create instances of this, rather use {@link TraceContext.Extractor} provided
 by a {@link Propagation} implementation such as {@link Propagation#B3_STRING}.

 <p>Those implementing {@link Propagation} should use the following advice:
 <pre><ul>
   <li>If you have the trace and span ID, use {@link #create(TraceContext)}</li>
   <li>If you have only a trace ID, use {@link #create(TraceIdContext)}</li>
   <li>Otherwise, use {@link #create(SamplingFlags)}</li>
 </ul></pre>
 <p>If your propagation implementation needs additional state, append it via {@link
 Builder#addExtra(Object)}.


 <p>This started as a port of {@code com.github.kristofa.brave.TraceData}, which served the same
 purpose.

 @see TraceContext.Extractor]]>
    </doc>
  </class>
  <!-- end class brave.propagation.TraceContextOrSamplingFlags -->
  <!-- start class brave.propagation.TraceContextOrSamplingFlags.Builder -->
  <class name="TraceContextOrSamplingFlags.Builder" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="context" return="brave.propagation.TraceContextOrSamplingFlags.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="context" type="brave.propagation.TraceContext"/>
      <doc>
      <![CDATA[@see TraceContextOrSamplingFlags#context()]]>
      </doc>
    </method>
    <method name="traceIdContext" return="brave.propagation.TraceContextOrSamplingFlags.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="traceIdContext" type="brave.propagation.TraceIdContext"/>
      <doc>
      <![CDATA[@see TraceContextOrSamplingFlags#traceIdContext()]]>
      </doc>
    </method>
    <method name="sampledLocal" return="brave.propagation.TraceContextOrSamplingFlags.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see TraceContext#sampledLocal()]]>
      </doc>
    </method>
    <method name="samplingFlags" return="brave.propagation.TraceContextOrSamplingFlags.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="samplingFlags" type="brave.propagation.SamplingFlags"/>
      <doc>
      <![CDATA[@see TraceContextOrSamplingFlags#samplingFlags()]]>
      </doc>
    </method>
    <method name="extra" return="brave.propagation.TraceContextOrSamplingFlags.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="extra" type="java.util.List"/>
      <doc>
      <![CDATA[Shares the input with the builder, replacing any current data in the builder.

 @see TraceContextOrSamplingFlags#extra()]]>
      </doc>
    </method>
    <method name="addExtra" return="brave.propagation.TraceContextOrSamplingFlags.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="extra" type="java.lang.Object"/>
      <doc>
      <![CDATA[@see TraceContextOrSamplingFlags#extra()]]>
      </doc>
    </method>
    <method name="build" return="brave.propagation.TraceContextOrSamplingFlags"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an immutable result from the values currently in the builder]]>
      </doc>
    </method>
  </class>
  <!-- end class brave.propagation.TraceContextOrSamplingFlags.Builder -->
  <!-- start class brave.propagation.TraceIdContext -->
  <class name="TraceIdContext" extends="brave.propagation.SamplingFlags"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="newBuilder" return="brave.propagation.TraceIdContext.Builder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="traceIdHigh" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[When non-zero, the trace containing this span uses 128-bit trace identifiers.]]>
      </doc>
    </method>
    <method name="traceId" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Unique 8-byte identifier for a trace, set on all spans within it.]]>
      </doc>
    </method>
    <method name="traceIdString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the hex representation of the span's trace ID

 @since 5.11]]>
      </doc>
    </method>
    <method name="toBuilder" return="brave.propagation.TraceIdContext.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns {@code $traceId}]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
      <doc>
      <![CDATA[Only includes mandatory fields {@link #traceIdHigh()} and {@link #traceId()}]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Only includes mandatory fields {@link #traceIdHigh()} and {@link #traceId()}]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Contains inbound trace ID and sampling flags, used when users control the root trace ID, but not
 the span ID (ex Amazon X-Ray or other correlation).]]>
    </doc>
  </class>
  <!-- end class brave.propagation.TraceIdContext -->
  <!-- start class brave.propagation.TraceIdContext.Builder -->
  <class name="TraceIdContext.Builder" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="traceIdHigh" return="brave.propagation.TraceIdContext.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="traceIdHigh" type="long"/>
      <doc>
      <![CDATA[@see TraceIdContext#traceIdHigh()]]>
      </doc>
    </method>
    <method name="traceId" return="brave.propagation.TraceIdContext.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="traceId" type="long"/>
      <doc>
      <![CDATA[@see TraceIdContext#traceId()]]>
      </doc>
    </method>
    <method name="sampled" return="brave.propagation.TraceIdContext.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sampled" type="boolean"/>
      <doc>
      <![CDATA[@see TraceIdContext#sampled()]]>
      </doc>
    </method>
    <method name="sampled" return="brave.propagation.TraceIdContext.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sampled" type="java.lang.Boolean"/>
      <doc>
      <![CDATA[@see TraceIdContext#sampled()]]>
      </doc>
    </method>
    <method name="debug" return="brave.propagation.TraceIdContext.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="debug" type="boolean"/>
      <doc>
      <![CDATA[@see TraceIdContext#debug()]]>
      </doc>
    </method>
    <method name="build" return="brave.propagation.TraceIdContext"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class brave.propagation.TraceIdContext.Builder -->
</package>
<package name="brave.sampler">
  <!-- start class brave.sampler.BoundarySampler -->
  <class name="BoundarySampler" extends="brave.sampler.Sampler"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="create" return="brave.sampler.Sampler"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="probability" type="float"/>
      <doc>
      <![CDATA[@param probability 0 means never sample, 1 means always sample. Otherwise minimum probability
 is 0.0001, or 0.01% of traces]]>
      </doc>
    </method>
    <method name="isSampled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="traceId" type="long"/>
      <doc>
      <![CDATA[Returns true when {@code abs(traceId) <= boundary}]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[This sampler is appropriate for high-traffic instrumentation (ex edge web servers that each
 receive >100K requests) who provision random trace ids, and make the sampling decision only once.
 It defends against nodes in the cluster selecting exactly the same ids.

 <h3>Implementation</h3>

 <p>This uses modulo 10000 arithmetic, which allows a minimum probability of 0.01%. Trace id
 collision was noticed in practice in the Twitter front-end cluster. A random salt is here to
 defend against nodes in the same cluster sampling exactly the same subset of trace ids. The goal
 was full 64-bit coverage of trace IDs on multi-host deployments.

 <p>Based on https://github.com/twitter/finagle/blob/b6b1d0414fa24ed0c8bb5112985a4e9c9bcd3c9e/finagle-zipkin-core/src/main/scala/com/twitter/finagle/zipkin/core/Sampler.scala#L68]]>
    </doc>
  </class>
  <!-- end class brave.sampler.BoundarySampler -->
  <!-- start class brave.sampler.CountingSampler -->
  <class name="CountingSampler" extends="brave.sampler.Sampler"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="create" return="brave.sampler.Sampler"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="probability" type="float"/>
      <doc>
      <![CDATA[@param probability probability a request will result in a new trace. 0 means never sample, 1
 means always sample. Minimum probability is 0.01, or 1% of traces]]>
      </doc>
    </method>
    <method name="isSampled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="traceIdIgnored" type="long"/>
      <doc>
      <![CDATA[loops over the pre-canned decisions, resetting to zero when it gets to the end.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[This sampler is appropriate for low-traffic instrumentation (ex servers that each receive <100K
 requests), or those who do not provision random trace ids. It is not appropriate for collectors
 as the sampling decision isn't idempotent (consistent based on trace id).

 <h3>Implementation</h3>

 <p>This initializes a random bitset of size 100 (corresponding to 1% granularity). This means
 that it is accurate in units of 100 traces. At runtime, this loops through the bitset, returning
 the value according to a counter.]]>
    </doc>
  </class>
  <!-- end class brave.sampler.CountingSampler -->
  <!-- start class brave.sampler.DeclarativeSampler -->
  <class name="DeclarativeSampler" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="brave.sampler.SamplerFunction"/>
    <method name="createWithProbability" return="brave.sampler.DeclarativeSampler"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="probabilityOfMethod" type="brave.sampler.DeclarativeSampler.ProbabilityOfMethod"/>
    </method>
    <method name="createWithRate" return="brave.sampler.DeclarativeSampler"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rateOfMethod" type="brave.sampler.DeclarativeSampler.RateOfMethod"/>
    </method>
    <method name="trySample" return="java.lang.Boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="method" type="java.lang.Object"/>
      <doc>
      <![CDATA[{@inheritDoc}

 @since 5.8]]>
      </doc>
    </method>
    <method name="create" return="brave.sampler.DeclarativeSampler"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="since 5.8, use {@link #createWithProbability(ProbabilityOfMethod)}">
      <param name="rateForMethod" type="brave.sampler.DeclarativeSampler.RateForMethod"/>
      <doc>
      <![CDATA[@since 4.4
 @deprecated since 5.8, use {@link #createWithProbability(ProbabilityOfMethod)}]]>
      </doc>
    </method>
    <method name="toSampler" return="brave.sampler.Sampler"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Since 5.8, use {@link Tracer#startScopedSpan(String, SamplerFunction, Object)}">
      <param name="method" type="java.lang.Object"/>
      <doc>
      <![CDATA[@since 4.4
 @deprecated Since 5.8, use {@link Tracer#startScopedSpan(String, SamplerFunction, Object)}]]>
      </doc>
    </method>
    <method name="toSampler" return="brave.sampler.Sampler"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Since 5.8, use {@link Tracer#startScopedSpan(String, SamplerFunction, Object)}">
      <param name="method" type="java.lang.Object"/>
      <param name="fallback" type="brave.sampler.Sampler"/>
      <doc>
      <![CDATA[@since 4.19
 @deprecated Since 5.8, use {@link Tracer#startScopedSpan(String, SamplerFunction, Object)}]]>
      </doc>
    </method>
    <method name="sample" return="brave.propagation.SamplingFlags"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Since 5.8, use {@link #trySample(Object)}">
      <param name="method" type="java.lang.Object"/>
      <doc>
      <![CDATA[@since 4.4
 @deprecated Since 5.8, use {@link #trySample(Object)}]]>
      </doc>
    </method>
    <doc>
    <![CDATA[This is an implementation of how to decide whether to trace a request using annotations on a java
 method. It is not an implementation of aspect-oriented or otherwise declarative tracing. See the
 test cases for this class for example implementations.

 <p>Example: A user defines an annotation, for example {@code com.myco.Traced}, and a lookup
 function for its rate (could be simple as reading a field, or even a constant). An interceptor
 uses this sampler on each invocation of a potentially annotated target. The result decides
 whether a new trace should be started or not.

 <p>No runtime parameters are considered here, but that doesn't mean you can't achieve
 parameterized sampling using this. If your method is annotated such that it only accepts a
 fraction of requests, adding a custom {@code @Traced} annotation would apply to that subset. For
 example, if you have a JAX-RS method, it is already qualified by method and likely path. A user
 can add and inspect their own grouping annotation to override whatever the default rate is.

 <p>Under the scenes, a map of samplers by method is maintained. The size of this map should not
 be a problem when it directly relates to declared methods. For example, this would be invalid if
 annotations were created at runtime and didn't match.

 @param <M> The type that uniquely identifies this method, specifically for tracing. Most often a
 trace annotation, but could also be a {@link java.lang.reflect.Method} or another declarative
 reference such as {@code javax.ws.rs.container.ResourceInfo}.
 @since 4.4]]>
    </doc>
  </class>
  <!-- end class brave.sampler.DeclarativeSampler -->
  <!-- start interface brave.sampler.DeclarativeSampler.ProbabilityOfMethod -->
  <interface name="DeclarativeSampler.ProbabilityOfMethod"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="get" return="java.lang.Float"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="method" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns null if there's no configured sample probability of this method]]>
      </doc>
    </method>
    <doc>
    <![CDATA[@since 5.8]]>
    </doc>
  </interface>
  <!-- end interface brave.sampler.DeclarativeSampler.ProbabilityOfMethod -->
  <!-- start interface brave.sampler.DeclarativeSampler.RateForMethod -->
  <interface name="DeclarativeSampler.RateForMethod"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="since 5.8, use {@link ProbabilityOfMethod}">
    <implements name="brave.sampler.DeclarativeSampler.ProbabilityOfMethod"/>
    <doc>
    <![CDATA[@since 4.4
 @deprecated since 5.8, use {@link ProbabilityOfMethod}]]>
    </doc>
  </interface>
  <!-- end interface brave.sampler.DeclarativeSampler.RateForMethod -->
  <!-- start interface brave.sampler.DeclarativeSampler.RateOfMethod -->
  <interface name="DeclarativeSampler.RateOfMethod"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="get" return="java.lang.Integer"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="method" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns null if there's no configured sample rate (in traces per second) of this method]]>
      </doc>
    </method>
    <doc>
    <![CDATA[@since 5.8]]>
    </doc>
  </interface>
  <!-- end interface brave.sampler.DeclarativeSampler.RateOfMethod -->
  <!-- start interface brave.sampler.Matcher -->
  <interface name="Matcher"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="matches" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="parameters" type="java.lang.Object"/>
    </method>
    <doc>
    <![CDATA[Returns true if this rule matches the input parameters

 <p>Implement {@link #hashCode()} and {@link #equals(Object)} if you want to replace existing
 rules by something besides object identity.

 @see Matchers
 @since 5.8]]>
    </doc>
  </interface>
  <!-- end interface brave.sampler.Matcher -->
  <!-- start class brave.sampler.Matchers -->
  <class name="Matchers" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="Matchers"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="alwaysMatch" return="brave.sampler.Matcher"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@since 5.8]]>
      </doc>
    </method>
    <method name="neverMatch" return="brave.sampler.Matcher"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@since 5.8]]>
      </doc>
    </method>
    <method name="and" return="brave.sampler.Matcher"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="matchers" type="java.lang.Iterable"/>
      <doc>
      <![CDATA[@since 5.8]]>
      </doc>
    </method>
    <method name="and" return="brave.sampler.Matcher"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="matchers" type="brave.sampler.Matcher[]"/>
      <doc>
      <![CDATA[@since 5.8]]>
      </doc>
    </method>
    <method name="or" return="brave.sampler.Matcher"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="matchers" type="java.lang.Iterable"/>
      <doc>
      <![CDATA[@since 5.8]]>
      </doc>
    </method>
    <method name="or" return="brave.sampler.Matcher"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="matchers" type="brave.sampler.Matcher[]"/>
      <doc>
      <![CDATA[@since 5.8]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Convenience functions to compose matchers for {@link ParameterizedSampler}.

 @see Matcher
 @see ParameterizedSampler
 @since 5.8]]>
    </doc>
  </class>
  <!-- end class brave.sampler.Matchers -->
  <!-- start class brave.sampler.ParameterizedSampler -->
  <class name="ParameterizedSampler" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="brave.sampler.SamplerFunction"/>
    <method name="newBuilder" return="brave.sampler.ParameterizedSampler.Builder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@since 5.8]]>
      </doc>
    </method>
    <method name="trySample" return="java.lang.Boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="parameters" type="java.lang.Object"/>
      <doc>
      <![CDATA[{@inheritDoc}

 @since 5.8]]>
      </doc>
    </method>
    <method name="sample" return="brave.propagation.SamplingFlags"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Since 5.8, use {@link #trySample(Object)}">
      <param name="parameters" type="java.lang.Object"/>
      <doc>
      <![CDATA[@since 4.4
 @deprecated Since 5.8, use {@link #trySample(Object)}]]>
      </doc>
    </method>
    <method name="create" return="brave.sampler.ParameterizedSampler"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="since 5.8, use {@link #newBuilder()}">
      <param name="rules" type="java.util.List"/>
      <doc>
      <![CDATA[@since 4.4
 @deprecated since 5.8, use {@link #newBuilder()}]]>
      </doc>
    </method>
    <doc>
    <![CDATA[This is an implementation of how to decide whether to trace a request using ordered rules. For
 example, you could write rules to look at an HTTP method and path, or a RabbitMQ routing key and
 queue name.

 <p>This looks at runtime parameters to see if they {@link Matcher#matches(Object) match} a rule.
 If all calls to a java method should have the same sample rate, consider {@link
 DeclarativeSampler} instead.

 @param <P> The type that encloses parameters associated with a sample rate. For example, this
 could be a pair of http and method.
 @see Matcher
 @since 4.4]]>
    </doc>
  </class>
  <!-- end class brave.sampler.ParameterizedSampler -->
  <!-- start class brave.sampler.ParameterizedSampler.Builder -->
  <class name="ParameterizedSampler.Builder" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="putAllRules" return="brave.sampler.ParameterizedSampler.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sampler" type="brave.sampler.ParameterizedSampler"/>
      <doc>
      <![CDATA[Adds or replaces all rules in this sampler with those of the input.

 @since 5.8]]>
      </doc>
    </method>
    <method name="putRule" return="brave.sampler.ParameterizedSampler.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="matcher" type="brave.sampler.Matcher"/>
      <param name="sampler" type="brave.sampler.Sampler"/>
      <doc>
      <![CDATA[Adds or replaces the sampler of the input matcher.

 @since 5.8]]>
      </doc>
    </method>
    <method name="build" return="brave.sampler.ParameterizedSampler"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@since 5.8]]>
    </doc>
  </class>
  <!-- end class brave.sampler.ParameterizedSampler.Builder -->
  <!-- start class brave.sampler.ParameterizedSampler.Rule -->
  <class name="ParameterizedSampler.Rule" extends="brave.sampler.ParameterizedSampler.R"
    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="Since 5.8, use {@link Builder#putRule(Matcher, Sampler)}">
    <implements name="brave.sampler.Matcher"/>
    <constructor name="Rule" type="float"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="matches" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="parameters" type="java.lang.Object"/>
    </method>
    <doc>
    <![CDATA[@since 4.4
 @deprecated Since 5.8, use {@link Builder#putRule(Matcher, Sampler)}]]>
    </doc>
  </class>
  <!-- end class brave.sampler.ParameterizedSampler.Rule -->
  <!-- start class brave.sampler.RateLimitingSampler -->
  <class name="RateLimitingSampler" extends="brave.sampler.Sampler"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="create" return="brave.sampler.Sampler"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tracesPerSecond" type="int"/>
    </method>
    <method name="isSampled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ignoredTraceId" type="long"/>
    </method>
    <doc>
    <![CDATA[The rate-limited sampler allows you to choose an amount of traces to accept on a per-second
 interval. The minimum number is 0 and the max is 2,147,483,647 (max int).

 <p>For example, to allow 10 traces per second, you'd initialize the following:
 <pre>{@code
 tracingBuilder.sampler(RateLimitingSampler.create(10));
 }</pre>

 <h3>Appropriate Usage</h3>

 <p>If the rate is 10 or more traces per second, an attempt is made to distribute the accept
 decisions equally across the second. For example, if the rate is 100, 10 will pass every
 decisecond as opposed to bunching all pass decisions at the beginning of the second.

 <p>This sampler is efficient, but not as efficient as the {@link brave.sampler.BoundarySampler}.
 However, this sampler is insensitive to the trace ID and will operate correctly even if they are
 not perfectly random.

 <h3>Implementation</h3>

 <p>The implementation uses {@link System#nanoTime} and tracks how many yes decisions occur
 across a second window. When the rate is at least 10/s, the yes decisions are equally split over
 10 deciseconds, allowing a roll-over of unused yes decisions up until the end of the second.]]>
    </doc>
  </class>
  <!-- end class brave.sampler.RateLimitingSampler -->
  <!-- start class brave.sampler.Sampler -->
  <class name="Sampler" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Sampler"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="isSampled" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="traceId" type="long"/>
      <doc>
      <![CDATA[Returns true if the trace ID should be measured.

 @param traceId The trace ID to be decided on, can be ignored]]>
      </doc>
    </method>
    <method name="create" return="brave.sampler.Sampler"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="probability" type="float"/>
      <doc>
      <![CDATA[Returns a sampler, given a probability expressed as a percentage.

 <p>The sampler returned is good for low volumes of traffic (<100K requests), as it is precise.
 If you have high volumes of traffic, consider {@link BoundarySampler}.

 @param probability probability a trace will be sampled. minimum is 0.01, or 1% of traces]]>
      </doc>
    </method>
    <field name="ALWAYS_SAMPLE" type="brave.sampler.Sampler"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="NEVER_SAMPLE" type="brave.sampler.Sampler"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Sampler is responsible for deciding if a particular trace should be "sampled", i.e. whether the
 overhead of tracing will occur and/or if a trace will be reported to the collection tier.

 <p>Zipkin v1 uses before-the-fact sampling. This means that the decision to keep or drop the
 trace is made before any work is measured, or annotations are added. As such, the input parameter
 to zipkin v1 samplers is the trace ID (lower 64-bits under the assumption all bits are random).

 <p>The instrumentation sampling decision happens once, at the root of the trace, and is
 propagated downstream. For this reason, the algorithm needn't be consistent based on trace ID.]]>
    </doc>
  </class>
  <!-- end class brave.sampler.Sampler -->
  <!-- start interface brave.sampler.SamplerFunction -->
  <interface name="SamplerFunction"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="trySample" return="java.lang.Boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="arg" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns an overriding sampling decision for a new trace. Returning null is typically used to
 defer to the {@link brave.Tracing#sampler() trace ID sampler}.

 @param arg parameter to evaluate for a sampling decision. null input results in a null result
 @return true to sample a new trace or false to deny. Null defers the decision.
 @since 5.8]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Decides whether to start a new trace based on request properties such as an HTTP path.

 <p>Ex. Here's a sampler that only traces api requests
 <pre>{@code
 serverSampler = new SamplerFunction<HttpRequest>() {
   @Override public Boolean trySample(HttpRequest request) {
     return request.path().startsWith("/api");
   }
 });
 }</pre>

 @param <T> type of the input, for example a request or method
 @see SamplerFunctions
 @see Request
 @since 5.8]]>
    </doc>
  </interface>
  <!-- end interface brave.sampler.SamplerFunction -->
  <!-- start class brave.sampler.SamplerFunctions -->
  <class name="SamplerFunctions" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="SamplerFunctions"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="nullSafe" return="brave.sampler.SamplerFunction"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delegate" type="brave.sampler.SamplerFunction"/>
      <doc>
      <![CDATA[Returns a function that returns null on null input instead of invoking the delegate with null.

 @since 5.8]]>
      </doc>
    </method>
    <method name="deferDecision" return="brave.sampler.SamplerFunction"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Ignores the argument and returns null. This is typically used to defer to the {@link
 brave.Tracing#sampler() trace ID sampler}.

 @since 5.8]]>
      </doc>
    </method>
    <method name="neverSample" return="brave.sampler.SamplerFunction"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Ignores the argument and returns false. This means it will never start new traces.

 <p>For example, you may wish to only capture traces if they originated from an inbound server
 request. Such a policy would filter out client requests made during bootstrap.

 @since 5.8]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Convenience sampling functions.

 @see SamplerFunction
 @since 5.8]]>
    </doc>
  </class>
  <!-- end class brave.sampler.SamplerFunctions -->
</package>

</api>
